[JavaScript]

[숫자와 문자]

-JS에서 실수형, 정수형 변수를 구분하지 않음 그냥 number로 통칭.

※JS에서 큰따옴표나 작은따옴표가 붙지 않은 숫자는 number로 인식한다.

[수의 연산]

-콘솔에다가 Math.pow(2,3); 을 하면 2의 3승이 출력된다.
  ->이때 "."은 객체라는 개념과 함께 나온다.
  -> Math라는 수학적인 명령어의 집합중에서 pow를 쓴다는 뜻으로 알기.

※Math.round(10.453); 
   :정수 반올림

  Math.ceil(10.453);
   :정수 올림

  Math.floor(10.453);
   :정수 내림

  Math.random();
   :1보다 작은 소수로써 난수 출력

  ->100*Math.ranmdom();
       :100이하의 난수 출력

e.g)
Math.round(Math.random()*100);
-> 100의 정수난수 출력

[문자]

-모든 문자열은 큰 따옴표나 작은 따옴표 사이에 작성해야함.(둘중 뭐든 상관 없음)

-작은 따옴표로 묶어진 문자열 안에 작은 따옴표를 넣고 싶다면
 작은 따옴표 앞에 역슬래쉬(\)를 넣어 이것이 문자임을 표현한다.
       ->\를 excape라고 함.

※ JS뿐만 아니라 모든 언어에서 그렇지만 1과 "1"은 다르다.
   
[문자 연산]

-\n,\t 같은 것들은 JS에서도 유효하다.

alert("Hello"+"World!");
:"+"를 통해 복수의 문자열을 연결할 수 있다.

※1+1은 2로출력 되지만 "1"+"1"은 "11"로 출력된다.

"randomstring".length
: 문자열의 문자개수를 출력한다.

"randomstring".indexOf("r")
: 어떤 문자열에서 특정 문자가 그 문자열에서 몇번째 인덱스를 차지하는지 말해준다.
  -> 위의 경우에는 0, 8이다.

[변수]

var a=1;
-> a라는 변수를 선언하고 1로 초기화(말했지만 변수형태 그딴거 없음)

-정수 실수 뿐만 아니라 문자열도 들어갈 수 있다.

var str="Hello";
alert(str+"World!");

->요로코롬

[주석]
-여기도 "//"랑 "/*...*/" 임.(C언어 동일)

[연산자]

※true 혹은 false를 나타내는 변수는 boolean이라고 불리는 데이터 형식이다.

[동등 비교연산자와 일치 연산자]
- "="은 대입연산자이며, "=="은 동등 비교 연산자이다.

-"==="는 일치 연산자라고 하며 좌항과 우항이 '정확하게' 같을때만 true를 반환한다.
  그말인 즉슨, 일치 연산자는 동등 연산자의 비교에 데이터의 타입도 비교하여 T/F를 판별한다.
 
e.g)

alert(1==="1");   //false!
alert(1=="1");     //true!

※왠만하면 ==쓰지 마라. 나중에 에러의 소지가 크다. 아예 쓰지말라고 한다.

var a;         //최기화를 했기에 변수에 값이 없음
var b=null;  //의도적으로 값이 없도록 함
alert(a);   //undefined라고 뜸
alert(b);  //null이라고 뜸

alert(a==b); //true!
alert(a===b); //false!

-> true/false 가 boolen이라는 데이터 타입이고, 1,2,3이 number,
    "a","b"가 string이라는 데이터 타입이듯이
    null은 null이라는 데이터 타입이고, undefined는 undefined이라는 데이터 타입이다.
    즉, 엄밀히 따지면(===연산시)둘은 다른게 맞다.

※"=="동등 연산자는 숫자 0을 제외한 모든 정수를 true와 같다고 판단한다.
   "==="는 당연히 아니다.

- 부등호 연산자(>,>=,<,<=)는 C언어와 동일

[조건문]

-if문, if-else문, if-else if-else문 C언어와 동일
---------------------------------------------
  if(boolean){
  }
  else if(boolean){
  }
  else{
  }
----------------------------------------------

※[prompt]
------------------------------------------
prompt("당신의 나이는?:");
------------------------------------------
->이렇게 하면 alert참 마냥 뜨긴하는데 사용자 입력이 가능한 입력창이 같이 뜬다.
   여기에 값을 입력하면 그 값이 console로 전송되어 뜬다.
---------------------------------------------------------------------
응용:

var id=prompt("아이디는 무엇인가요?:");

->id를 입력받아 변수에 저장한다.

alert(prompt("출력할 수는?:"));

->이렇게 하면 수를 입력받고 똑같이 출력하게된다.
---------------------------------------------------------------------
-------------------------------------------------------------------
if문 예제)

var id= prompt("id 입력:"); 

if(id==="5502ghals"){
alert("아이디 동일! 어서오세요"+id+"님!");
}
else 
alert("넌 누구냐!");
-------------------------------------------------------------------

[논리 연산자]
:&&,||,! C언어와 동일


[boolean의 대체제]

-숫자 1(사실 0이 아닌 모든 number)은 true로 간주되고, 0은 false로 간주된다.

-빈 문자열 ' '또한 false로 간주된다.

-undefined와 null도 false로 간주된다.

예를 들어 다음과 같이 할 수도 있다.

var a;   //a는 undefined
if(!a){alert("할당되지 않은 변수!");}


[반복문]

※document.write("HTML cord");
  ->문자열을 HTML코드로 해석하여 실행하는 명령어 
     (변수는 변수대로 출력가능)
------------------------------
e.g)
document.write("Hello world! <br>");
------------------------------


[while문]
--------------------------------------------------------
반복문 응용)

while(true){  //무한루프
document.write("Hello world! <br>");
}

var i=0;
while(i<5){  //5회 반복
document.write("Hello world! <br>"+i);
i=i+1;
}
--------------------------------------------------------------

[for문]
----------------------------------------------------
e.g)
for(var i=0;i<5;i++){
	document.write("Hello world!"+i+"<br>");
}
--------------------------------------------------

[반복문의 제어; break,continue]

-C언어와 동일

※다음의 코드를 보자
------------------------------------------
var a=10,b=4;
document.write("a와 b는 각각 "+a+b+" 이다.<br>");
------------------------------------------
-> 위 코드에서 a+b부분은 문자열 사이에 껴져 있기 때문에 자연스럽게
    문자열로 해석되어 number의 연산으로써의+가 아닌 문자열을 결합해주는
    +로 해석되어 "a와b는 각각 104 이다."라고 출력된다. 


[함수]

[함수의 형식]
------------------------------------------
function funcname (parameter,...){
	(코드....)
	
	return 반환값;
}
------------------------------------------

-위와 같이 함수를 정의(선언)하고, 호출할때는 funcname();와 같이 호출한다.
----------------------------------------------------------
e.g)

<script>
function numbering (){
	document.write(1); 
}
numbering();   //()가 없으면 JS에는 변수로 취급
</script>
----------------------------------------------------------


[함수의 출력]
----------------------------------------------------
function get_member1(){
	return 'Hello?';
}

function get_member2(){
	return 'World!';
}

alert("get_member1");    //hello 출력
alert("get_member2");   //World 출력
------------------------------------------------------
->다음과 같이 사용가능, 반환값은 함수의 자리를 차지한다

-이때,
----------------------------------------
function get_member1(){
	return 'Hello?';
	return 'World!';
}
alert("get_member");  //Hello? 출력
-----------------------------------------
-> return문을 한번 지나면 이미 그 함수는 탈출한것이기 때문에
    return문 뒤의 코드는 의미가 없다.


[함수의 입력]
-----------------------------------------
function get_argument(arg){         //c언어와 다르게 변수 선언문이 들어가지 않고 파라미터만 단독으로 씀
	return arg*1000;
}

alert(get_argument(1));  //1000출력
alert(get_argument(2));  //2000출력
------------------------------------------

*위의 함수 선언에서 인자들은 '파라미터(parameter)'라고 부르며
 함수 호출에서 파라미터에 들어간 값들은 '알규먼트(argument)'라고 부른다.

---------------------------------------------------
e.g) 복수 파라미터 
function get_argument_plus(arg1,arg2){         
	return arg1+arg2;
}

alert(get_argument_plus(10,20));  //30출력
------------------------------------------------------

[함수를 정의하는 다른 방법]

1. 함수의 대입
-----------------------------------------------------
var numbering = function (){  //numbering이라는 변수에 함수를 대입
    i = 0;
    while(i < 10){
        document.write(i);
        i += 1;
    }   
}
numbering();            //그래도 변수로 연산하는게 아니므로 함수로써 쓸데는 뒤에() 붙음
----------------------------------------------------

2. 익명함수
----------------------------------------------------
(function (){  
    i = 0;
    while(i < 10){
        document.write(i);
        i += 1;
    }   
})();           //익명함수: 함수를 선언과 동시에 실행
----------------------------------------------------
-이름이 없으며 1회 실행을 위해 존재(이름이 없으니 추가 호출이 불가)


[배열]
-연관된 데이터를 통으로 모아 관리하기 위해 사용하는 데이터 타입이다.

----------------------------------------------
var member=['a', 'b', 'c'];
alert(member);         //a, b, c 출력됨
------------------------------------------------
-배열안에 들어있는 값들을 각각 원소(element)라고 부름.

---------------------------------------------------------
var member=['a', 'b', 'c'];

alert(member[0]);
alert(member[1]);
alert(member[2]);  //index는 c언어와 같음(0,1,2...)
----------------------------------------------------------
-다음과 같이 각 요소를 호출함

[배열의 효용/ 배열과 반복문 응용]
-----------------------------------------------------------
e.g1)

var member=['egoing', 'k8805', 'sorialgi'];

for(var i=0;i<=2;i++){
	alert("name is "+member[i]);
}
------------------------------------------------------------

-------------------------------------------------------------
e.g2) members.length()를 이용한 for문 효율 극대화

var members=get_members(){
	return ['egoing', 'k8805', 'sorialgi'];
}
// var members=['egoing', 'k8805', 'sorialgi'];와 동일

for(var i=0;i<members.length();i++){    
	document.write(members[i].toUpperCase()+"<br />");
}

*member.toUpperCase()
:내장함수; member에 담긴 문자(들)의 소문자를 모두 대문자로 바꿔주는 함수 

*member.length()
:내장함수; member라는 배열에 담긴 요소(element)의 갯수를 반환하는 함수
--------------------------------------------------------------

[배열의 제어]

[배열의 추가]

---------------------------------------------------------------
var li=['a','b','c','d','e'];

li.push('f');   //배열의 맨 끝에 f 추가

document.write(li);  // a,b,c,d,e,f 출력

li=li.concat(['g','h']);  //추가 배열을 더 붙일때는 concat 함수사용

 //concat으로 li에 g,h를 붙인 a,b,c,d,e,f,g,h라는 
 배열을 li에 저장하여 결과적으로 g,h가 추가되게 됨.

document.write(li);  //a,b,c,d,e,f,g,h 출력

*member.push('element')
: 내장함수; 배열 member의 맨 끝에 'element'에 해당하는 요소를 추가

**member.concat(element1,element2,..)
: 내장함수; 배열 member에 element1,element2,..에 해당하는 요소들을 추가한 값을 반환함

 ->반환만 하므로 배열에 추가하기 위해선
    member=member.concat(element1,element2,..); 
    이렇게 사용함.
---------------------------------------------------------------
---------------------------------------------------------------
var li=['a','b','c','d','e'];

li.unshift('z');   //함수의 맨 앞에 z추가.

document.write(li);   //z,a,b,c,d,e 출력

li.splice(2,0,'k');  //index2부터 0개의 요소를 삭제하고 k를 추가하라
//삭제할 요소의 개수가 0이면 해당 index바로 앞에 삽입된다.
document.write(li);   //z,a,k,b,c,d,e 출력

*member.splice(index,num,element1,element2)
 : 1.내장함수; 배열 member의 index에서 부터 num만큼의 요소를 삭제하고 
     index에서 부터 elements를 삽입하라

   2. 삭제한 요소들을 반환

   ->예를 들어 a,b,c라는 member가 있다고 치자, 이때
       var a=member.splice(1,1,'j','k'); 을 실행하면
       member에는 a,j,k,c가 저장되고, a 에는 ['b']라는 배열이 반환되어 저장된다.

-----------------------------------------------------------------------

[배열의 제거]
-----------------------------------------------------------------------
var li=['a', 'b', 'c', 'd', 'e',];

li.shift();   //li의 맨 처음 요소 제거

li.pop();   //li의 맨 마지막 요소 제거

document.write(li);  //b, c, d 출력

*member.shift() :내장함수; member배열의 index[0]제거
**member.pop():내장함수; member배열의 index[member.length()-1]제거
----------------------------------------------------------------------

[정렬]
--------------------------------------------------------------------
var li=['b', 'a', 'c', 'e', 'd'];  //뒤죽박죽

li.sort();   //ASCII 코드 순 정렬

document.write(li); // a, b, c, d, e 출력

li.reverse();  //ASCII코드 역순 정렬

document.write(li); // e, d, c, b, a 출력

*member.sort()
**member.reverse()
-------------------------------------------------------------


[객체(object)]

-배열은 아이템에 대한 식별자로 숫자(;인덱스)를 사용했다. 만약
 인덱스로 문자를 사용하고 싶다면 객체를 사용하면 된다.

[객체의 선언(1)]
-----------------------------------------------------------
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};  //배열과 달리 중괄호를 사용
------------------------------------------------------------
-각 egoing이라는 객체체 10이라는 값이 들어가고
  k8805에 6이 들어가고 sorialgi에는 80이 들어간다.

-이때 객체에서 각 칸의 이름(egoing,k8805...)은 key라고 하며
 안에 들어간 값은 value라고한다.

[객체의 선언(2)]
-----------------------------------------------------------------
var grade={};

grade['egoing']=10;
grade['k8805']=6;
grade['sorialgi']=80;   //여기는 대괄호이다.
---------------------------------------------------------------
var grade=new object{};     //var grade={};와 같다.

grade['egoing']=10;
grade['k8805']=6;
grade['sorialgi']=80; 
-------------------------------------------------------------

[객체의 호출]
-------------------------------------------------------------
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};

document.write(grade['egoing']);  // key의 이름을 꼭 (큰)따옴표로 감쌀것

document.write(grade.egoing);    //이도 위와 같다.
------------------------------------------------------------

-즉, "member.key"라는 호출문을 통해value를  호출한다.

-이때, 다음도 가능하다.
------------------------------------------------------
document.write(grade['ego'+'ing']);

document.write(grade.'ego'+'ing');  //이건 안됨!!
------------------------------------------------------


[객체와 반복문 응용]

-배열에는 순서(index)가 있기 때문에 반복문과 응용해서 하나하나
 지정이 가능했다.(배열에 순서가 있다는 것은 중요한 요소임!)

-그러나 객체는 순서가 존재하지 않고 단지 key와 value가 있을 뿐이다.

-그래서 조금 다른 종류의 반복문으로 이를 해결한다.
-------------------------------------------------------------------
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};

for(key in grades) {
    document.write("key : "+key+" value : "+grades[key]+"<br />");
}

*for(key in member){ }
: 반복문을 실행하며 객체가 선언된 순서대로(선언할때 중괄호 안 순서)
  key값에 해당하는 문자열을 key라는 변수이름으로 지역변수선언
-------------------------------------------------------------
//key in member 이해
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};

for(key in grades) {
    document.write(key+"<br />");
}
//egoing,k8805,sorialgi가 차례로 출력된다.
--------------------------------------------------------------
--------------------------------------------------------------------


-반복문 안의 지역변수이름은 꼭 key가 아니여도 된다.
--------------------------------------------------------------------
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};

for(var name in grades) {
    document.write("key : "+name+" value : "+grades[name]+"<br />");
}

//key대신 var name이라고 선언해줘야함.
-------------------------------------------------------------------

-다음과 같이 HTML과 같이 응용가능하다.(JS를 이용한 HTML제어)
------------------------------------------------------------------
<ul>
<script>
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};

for(var name in grades) {
    document.write("<li>key : "+name+" value : "+grades[name]+"</li>");
}
</script>
</ul>
//위 출력을 unordered list의 형태로 출력시킴.
-------------------------------------------------------------------

※for(var key in member){}는 객체가 아니라 배열에서도 동작한다.
  배열은 객체와 같지만 key가 0,1,2로 되어있으므로, key에 해당하는 
  지역변수값은 반복문 순환마다 0,1,2 식으로 초기화된다.

[객체안에 담을수 있는 것들]
----------------------------------------------------------------
var grades = {
    'list': {'egoing': 10, 'k8805': 6, 'sorialgi': 80},
    'show' : function(){
        alert(this.list); // egoing: 10, k8805: 6, sorialgi: 80 출력

        for(var name in this.list){
            document.write(name+':'+this.list[name]+"<br />");
        }
    }
};

document.write(grades['list']['egoing']); //이는 10을 호출함
grade['show']();    //객체안에 있는 함수 호출시 ()의 위치 주의
//grade.show(); 도 정상동작한다.

*this: 함수가 소속되어있는 객체의 이름을 반환
--------------------------------------------------------------


[모듈(module)]

-하나의 코드를 여러개의 파일로 분리하는 것을 모듈(module)화라고함

----------------------------------------------------------------
[모듈의 효율]

-자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용할 수 있다.

-코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.

-코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.

-필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.

-한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에
 동일한 로직을 로드 할 때 시간과 네트워크 트래픽을 
 절약 할 수 있다. (브라우저에서만 해당)
-----------------------------------------------------------

-순수 JS에서는 모듈이라는 개념을 지원하지 않지만, JS가
 구동하는 호스트 환경(서버(node.JS),브라우저(JS)등..)에 따라서
 서로 더른 모듈화 방법이 제공되고 있다.

-본 글에서는 브라우저 호스트환경에서의 모듈화를 중점적으로 설명하겠음.

[모듈화]

-------------------------------------------------------
//모듈이 없는 HTML 코드이다.
//main.html 
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
</head>
<body>
    <script>
        function welcome(){
            return 'Hello world';
        }
        alert(welcome());
    </script>
</body>
</html>
-------------------------------------------------------

->다른 페이지에서 welcome이라는 함수를 사용하고, 또 반복적으로
    많이 호출된다고 하면 모듈이 큰 힘을 발휘한다.

1.우선 모듈화를 할 JS코드를 짜고, greeting.js이라고 파일을 지정하자.
--------------------------------------------------------
//greeting.js
function welcome(){
            return 'Hello world';
        }
--------------------------------------------------------

2.모듈을 불러와보자.
------------------------------------------------------------
//main.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <script type="text/javascript" scr="greeting.js"></script> 
//script태그의 scr속성을 통해 모듈의 주소를 지정해주면 해당 주소의 JS코드가 script태그 안으로 삽입되게 된다.
</head>
<body>
    <script>
        alert(welcome());     //위에서 모듈을 가져와서 welcome() 함수를 선언했기 때문에 welcome() 사용가능하다.
    </script>
</body>
</html>

*script태그의 type="text/javascript"속성은 생략가능하다.
-----------------------------------------------------------


3. 다른 페이지에서도 해당모듈은 사용가능하다.
-------------------------------------------------
//sub.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <script scr="greeting.js"></script> //모듈은 head태그 안에서 가져와야한다는거 주의!
</head>
<body>
    <script>
        alert(welcome());  
    </script>
</body>
</html>
-------------------------------------------------


[라이브러리]

-모듈과 비슷하지만 자주 사용하는 로직을 잘 정리한 코드들의 집합에 중점

-주로 오픈소스로 공개되어 있음 

---------------------------------------------------------
대표적인 라이브러리 JQuery)

1. JQuery 다운로드 (홈페이지 가서 다운로드, 혹은 그냥 복붙으로 가져오기, 코드 그대로 사이트에 있음)

2.jQuery 메뉴얼을 이용해서 사용법을 익히고 써먹는다.
------------------------------------------------
e.g 1)

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <script type="text.javascript" scr="jquery.js"></script> 
</head>
<body>
    <ul id="list">
           <li>empty</li>
           <li>empty</li>
           <li>empty</li>
          <li>empty</li>
    </ul>
<script type="text.javascript">
    $('#list li').text('coding every body');
        
</script>
</body>
</html>

*('#list li')
: id 값이 list인 태그를 가리키는 '#list'에다 
 #list li 는 그 id=list인 태그 안의 모든 li태그를 가르킨다.

**('#list li').text('coding every body');
: 위 *에서 설명한 모든 li태그의 내용을 'coding every body'로 바꾸는 것이다.
---------------------------------------------------------

e.g 2)

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <script type="text.javascript" scr="jquery.js"></script> 
</head>
<body>
    <ul id="list">
           <li>empty</li>
           <li>empty</li>
           <li>empty</li>
          <li>empty</li>
    </ul>
    <input type="button" value="excute" id="excute_btn"/>
<script type="text.javascript">
    $('#excute_btn').click(function(){
	$('#list li').text('coding every body');
        });
</script>
</body>
</html>

->button을 추가해서 버튼을 누르면 #list li의 값이 바뀌도록 함.
-----------------------------------------------------------------------

[정규표현식]

-문자열에서 특정한 문자를 찾아내거나 찾은 특정 문자열을 치환하는 등의 역할을
 해주는 도구이다.

-정규표현식은 JS와 같은 하나의 언어이다. 

-본 글에서는 JS내에서 정규표현식을 사용하는 방법을 중점적으로 다룬다.

-정규표현식을 사용할수 있는 언어는 JAVA를 포함해 perl같은 언어에서도 쓸수 있다.

[정규표현식의 사용법(JS)]

-컴파일이라는 단계와 실행이라는 단계를 거친다.
-------------------------------------------------------------
1.컴파일
-우리가 필요한 대상(패턴)을 찾는 단계

2.실행
-대상에 대해 구체적인 작업을 하는 단계
--------------------------------------------------------------

[패턴 만들기]

1."정규표현식 리터럴" 방식

------------------------------
var pattern=/a/;              
------------------------------
->위와같이 pattern이라는 변수를 선언할때 초기화 값의 앞, 뒤에 "/"를 붙여
   "a"가 패턴이라는 것을 알려주며 이를 pattern에 저장한다.


2."정규표현식 객체 생성자" 사용

----------------------------------
var pattern=new RegExp('a');
----------------------------------
->위와같이 new RegExp(Regular Expression)을 사용하여 
    패턴을 변수에 담는다.

[정규표현식 메소드 실행]

-이제 변수에 패턴을 지정해줬으니 그 패턴으로 메소드를 실행해보자.

----------------------------------------------------------------
//@기본
var pattern=/a/;      //패턴은 'a'야!

pattern.exec('abcde'); //'abcde'중에 a문자열을 찾고싶어!
//["a"] 출력

//@패턴에서 "."의 의미
var pattern=/a./;      //패턴은 'a'+문자 한개 더(.)야!

pattern.exec('abcde');
//["ab"] 출력

//@찾는값이 없다면?
var pattern=/a/;     

pattern.exec('bcdef');
//null 출력

*RegExp.exec
 :RegExp에 담긴 패턴을 파라미터 문자열에서 찾아 있다면 
  그 값을 배열로 리턴하는 메소드
------------------------------------------------------------------

var pattern=/a/;     

pattern.test('abcde');
//true 출력

pattern.test('bcdef');
//false출력

*RegExp.test
: 패턴이 파라미터 문자열에 존재하는지 boolean값으로 리턴
-------------------------------------------------------------------


[문자열 메소드 실행]
-----------------------------------------------------------
var pattern=/a/;     

var str='abcdef';

str.match(pattern);
//["a"]출력

str='bcdef';

str.match(pattern);
//null 출력

str.match(RegExp);
:RegExp.exec()와 비슷하다. RegExp에 패턴이 들어가고, str에 파라미터가 들어간다.
------------------------------------------------------------
var pattern=/a/;     

var str='abcdef';

str.replace(pattern,'A');
//Abcdef출력

str.replace(RegExp,str_complement);
: RegExp에 담긴 패턴을 str에서 찾아 그 값을 str_complement 값으로 바꾼다.
-------------------------------------------------------------

[옵션]

var pattern=/[패턴]/[옵션];
->해당 형식을 띈다.

i 옵션 (;ignore)
: 대소문자를 구분하지 않는다.
--------------------------------------------------------
e.g)

var xi = /a/;   
console.log("Abcde".match(xi));  // null 출력

var oi = /a/i;      //'a'가 패턴인데 대소문자는 신경쓰지마(i)!
console.log("Abcde".match(oi));  // ["A"]; 출력

*console.log();
:설명하기 늦긴하지만 이건 콘솔창에 ()안 값을 출력할 때 쓴다.
--------------------------------------------------------

g 옵션 (;global)
: 검색된 모든 결과같을 리턴한다. 즉, 반복해서 나온 패턴 검사값을 모두 반환함.
-------------------------------------
var xg = /a/;
console.log("abcdea".match(xg));   //["a"] 출력

var og = /a/g;
console.log("abcdea".match(og));  //["a","a"] 출력
-------------------------------------

※pattern.exec("str"); 과는 다르게 g옵션 사용한 match 메소드실행은
  각 결과값을 다른 배열에 넣는다.(['ab'] !=['a','b'])

※var pattern=/a/ig; 
  ->이렇게 겹치도록 옵션사용이 가능하다.


[사례: 캡쳐]
--------------------------------------
var pattern = /(\w+)\s(\w+)/;
--------------------------------------
->다음과 같이 패턴을 지정했다 하자. 이를 해석해 보자면,
------------------------------------------------------------
(\w+)\s(\w+) -> (\w+) \s  (\w+)

(\w+)
-괄호로 닫히면 괄호 안의 내용은 group으로 치부되어 후에 메소드에 사용될 수 있다.
-\w 는 word로써 문자을 의미한다. 이때, 특수문자는 \w에 해당되지 않고
 0~9 a~z A~Z만을 의미한다.
- "+"는 '수량자'라고하며 이로 인해 (\w+)는 1개 이상의 복수의 문자를 의미하게 된다.

\s
-띄어쓰기

->이는 결국 사이에 띄어쓰기를 둔 두 문자열을 패턴으로 둔 셈이 된다.
------------------------------------------------------------

-----------------------------------------------
var str = "coding everybody";
var result = str.replace(pattern, "$2, $1");
console.log(result);
------------------------------------------------
-> 이후 str이라는 문자열을 선언하고
   replace메소드를 실행하였다.

-이때 $1 ,$2 는 각각 그룹1과 그룹2 를 의미하며 여기서의 그룹은
 패턴에서 가져온다. ()로 묶인 것이 순서대로 그룹이다.

-그럼 결국 str.replace(pattern, "$2, $1") 는 해당 패턴을 발견하면 
 띄어쓰기를 사이에 둔 두마디를 뒤집고 사이에 콤마를 넣으라는 메소드 실행이 된다.

[치환]
-----------------------------------------------------------------------
e.g)

var pattern=/(url을 찾는 정규표현식~)/;

var content="네이버의 url은 https://www.naver.com이고 구글은 https://www.google.com입니다."

var result=content.replace(pattern,function(url){return '<a href="'url'">'+url+'</a>'});

//이때 function에 들어가는 parameter인 url은 정규표현식에 의해 들어가진다.
------------------------------------------------------------------------


