[Injection]

-Injection은 주입이라는 의미를 가지고 있다. 
 인잭션 공격은 사용자의 입력 데이터가 어플리케이션의 처리 과정에서 
 구조나 문법적인 데이터로 해석되어 발생하는 취약점을 의미한다.

-변조된 입력을 주입해 의도한 행위를 변질시켜 
 의도하지 않은 행위를 발생 시킨다.
-----------------------------------------------------------------------------
SQL Injection:
SQL 요청을 사용할 때 공격자의 입력 값이 정상적인 요청에 영향을 주는 취약점입니다.

Command Injection:
OS Command를 사용 시 사용자의 입력 데이터에 의해 실행되는 Command를 변조할 수 있는 취약점입니다.

Server Side Template Injection (SSTI):
템플릿 변환 도중 사용자의 입력 데이터가 템플릿으로 사용돼 발생하는 취약점입니다.

Path Traversal:
URL / File Path를 사용 시 사용자의 입력 데이터에 의해 임의의 경로에 접근하는 취약점입니다.

Server Side Request Forgery (SSRF):
공격자가 서버에서 변조된 요청을 보낼 수 있는 취약점입니다.
------------------------------------------------------------------------------

[SQL Injection]

-웹 어플리케이션은 다양한 데이터를 관리하기 위해 DBMS을 사용한다.

-DBMS는 Structured Query Language(SQL)이라는 질의 언어를 
 사용하여 DB와 상호작용 가능하다.

-웹 어플리케이션에서 로그인/검색과 같이 사용자의 입력 데이터를 기반으로
 DBMS에 저장된 정보를 조회하는 기능을 구현하기 위해 SQL쿼리에 사용자의
 입력 데이터를 추가하여 BDMS에 요청한다.

-이 과정에서 사용자의 입력이 SQL쿼리에 삽입되어 SQL구문으로 
 해석되거나 문법적으로 조작하게 되면 개발자가 의도한 정상적인
 SQL쿼리가 아닌 임의의 쿼리가 실행 될 수 있습니다.

-즉, SQL Injection은 SQL쿼리에 사용자의 입력 데이터가 삽입되어
 사용자가 원하는 쿼리를 실행할 수 있는 취약점이다.
 
-SQL Injection이 발생하게되면 현재 쿼리를 실행시키는 DBMS계정의 
 권한으로 공격이 가능하며 일반적으로 데이터베이스의 자료를 추출하거나
 삭제하는 등의 행위가 가능하다.

[SQL]

-SQL(Structed Query Language)는 말 그대로 구조화된 형태를 가지는 언어이다.
 올바른 구조로 요청해야 DB가 이해하고 요청한 데이터를 수행하게 된다.

-SQL은 사용목적과 행위에 따라 다양한 구조가 존재하며, 대표적으로
 아래와 같이 구분된다.
-----------------------------------------------
DDL (Data definition language):
데이터를 정의하기 위한 언어입니다. 
데이터를 저장하기 위한 스키마, 데이터베이스의 생성/수정/삭제 등의 
행위를 수행합니다.

DML (Data manipulation language):
데이터를 조작하기 위한 언어입니다. 
실제 데이터베이스 내에 존재하는 데이터에 대해 
조회/저장/수정/삭제 등의 행위를 수행합니다.

DCL (Data control language):
데이터베이스의 접근 권한 등의 설정을 하기 위한 언어입니다. 
데이터베이스내에 사용자의 사용 권한을 부여하기 
위한 GRANT와 권한을 박탈하는 REVOKE가 대표적인 DCL입니다.
------------------------------------------------

1. DDL

-DDL에서 사용되는 대표적인 예시는 다음과같다.
------------------------------------------------------------------------------
CREATE:
새로운 DB또는 테이블을 생성한다.
-------------------------------------------------
CREATE TABLE Board(
	idx INT AUTO_INCREMENT,
	boardTitle VARCHAR(100) NOT NULL,
	boardContent VARCHAR(2000) NOT NULL,
	PRIMARY KEY(idx)
)
-------------------------------------------------
-위 명령어를 통해 원하는 컬럼을 가진 Board테이블을 생성할 수 있다.
  (속성은 idx, boardTitle, boardContent)
*테이블: 데이터베이스의 모든 데이터를 포함하는 데이터베이스의 개체이다.
            테이블에서 데이터는 스프레드시트와 비슷한 논리적인 행 및 열 형식으로 
            구성된다.

ALTER:
데이터베이스 또는 테이블의 속성을 변경한다.
------------------------------------------------
ALTER TABLE Board ADD createdDate date;
------------------------------------------------
-위 명령어를 통해 테이블에 새로운 칼럼(createdDate라는 이름)을 추가 할 수 있다.

DROP: 
데이터베이스 또는 테이블을 삭제한다.
--------------------------
DROP TABLE Board;       //DROP TABLE까지 명령어, 그 뒤에 이름(Board)
--------------------------

---------------------------------------------------------------------------------

2.DML

-DML에서 사용되는 대표적 예시는 다음과 같다.
------------------------------------------------------------------------------
INSERT:
테이블에 새로운 데이터를 추가한다.
--------------------------------------------------------
INSERT INTO 
  Board(boardTitle, boardContent, createdDate) 
Values(
  'Hello', 
  'World !',
  Now()
);
---------------------------------------------------------
-위 명령어를 통해 테이블에 새로운 데이터를 추가할 수 있다.
   (Board라는 테이블의 각 boardTitle,mboardContent,createdDate라는 속성에
    Hello와 World!와 현재 시각(Now()를 사용)을 추가삽입)

UPDATE:
테이블에 존재하는 데이터를 수정한다.
----------------------------------------------------
UPDATE Board SET boardContent='DreamHack!'   //Board라는 테이블의 boardContent 속성을 수정함
  Where idx=1;   
-------------------------------------------------------

SELECT:
테이블에 존재하는 모든 데이터를 조회함.
------------------------------------
SELECT 
  boardTitle, boardContent
FROM
  Board
Where
  idx=1;
------------------------------------

-위 명령어를 DB에 요청해서 아래와 같은 데이터를 얻을 수있다.
---------------------------
Hello, DreamHack!
---------------------------

-DELETE:
테이블에 존재하는 데이터를 삭제한다.
----------------------
DELETE From 
  Board
Where 
  idx=1;                //idx(인덱스)의 1 이라는 건 처번째 줄을 다 없애겠다는 뜻임.
-----------------------

--------------------------------------------------------------------------------

-사용자의 입력 데이터가 SQL쿼리에 들어가는 대표적인 예시로는 로그인 기능이다.
 사용자가 아이디와 패스워드를 입력해 서버에 전송하면 서버는 해당 데이터가
 DB에 있는지 확인하고 로그인에 성공시킬지 실패시킬지 파난할 수 있다.

-MySQL에서의 로그인을 처리하는 가장 간단한 형태의 쿼리는 다음과 같다.
-----------------------------------------------------
select * from user_table
where uid='{uid}' and upw='{upw}';
-------------------------------------------------------
-사용자가 자신의 아이디와 패스워드를 입력하면 웹 어플리케이션에서
 {uid},{upw}부분에 사용자가 입력한 문자열로 대체되어 들어가고 DBMS로
 전달되어 실행한다.

-위 SQL 쿼리는 사용자의 입력과 웹 어플리케이션이 작성한 SQL쿼리를 
 구분할 때 '(따옴표)를 기준으로 문자열을 구분하고 있다. 만약 사용자가 입력에
 '를 포함시켜 문자열을 탈출하고 뒷 부분에 새로운 쿼리를 작성하면 DBMS에서
 사용자가 입력한 쿼리를 실행시킬 수 있다.
------------------------------------------------------------------------------
예를 들어, 아이디가 guest고 비번이 guest1이라고 하자.

 이때 옳은 아이디를 입력하면
-------------------------------------------
uid: guest
upw:guest

select * from user_table where uid='guest' and upw='guest';
-------------------------------------------
이런 쿼리가 작성되고, 로그인에 성공하게 된다.

SQL Injection을 해보자.
---------------------------------------------------------
 uid: admin' or '1
 upw:1

select * from user_table where uid='admin' or '1' and upw='1';
---------------------------------------------------------
->이 쿼리는 uid가 admin인 경우 참이 되도록 설정했다.

또는 (아래 이 아이디/비밀번호가 공격 페이로드로써 많이 쓰이는듯)
--------------------------------------------------------------
uid=1' or '1
upw=1' or '1

select * from user_table where uid='1' or '1' and upw='1' or '1';
---------------------------------------------------------------
->모든 조건이 참이 되도록 설정했다.
-----------------------------------------------------------------------------

-SQL Injection 취약점을 막기 위해서는 사용자의 입력 데이터가 SQL 쿼리로
 해석되지 않아야한다.

-앞에서의 경우 사용자의 입력값에 문자열 구분자(',")가 들어있어 원래의 쿼리 향태를 벗어나
 SQL Injection이 일어난 것이므로, 이를 막아야 한다. 과거에는 문자열의 구분자 앞에 \를 붙여
 사용자의 입력을 escape해 사용하는 방식을 자주 이용했지만 최근에는 아니다.

-왜냐하면 사용자로부터 입력을 받는 타입은 아이디, 패스워드와 같이 문자열 뿐만 아니라
 숫자 타입일 수도 있기 때문이다. 

-예를 들어 게시판의 게시글 순서를 나타내는 게시글의 제목을 쿼리에 사용하는 것보다
 게시글의 순서를 나타내는 게시글의 순번으로 조회하는 것이 더 간단하기 때문에
 많이 사용하는 편이다. 이 경우 문자열 구분자들이 모두 escape했더라도 숫자 뒤에
 공백문자(' ' 혹은 \n)를 넣는 것만으로도 바로 쿼리에 사용자 입력을 삽입할 수있기 때문에
 SQL Injection이 발생할 수 있다.
-----------------------------------------------------------------
e.g)
select * from board_table where post_idx=100 or 1=1;  //삽입한건 100 or 1=1이라는 문자열
------------------------------------------------------------------

->위 예제는 구분자를 삽입하지 않았찌만 SQ injection을 통해 where절의 조건을 할상 참이 되도록 하였다.

-권장되는 방어법은 ORM같은 검증된 SQL라이브러리를 사용하는 것이다.
 ORM이란 Object Relational Mapper의 약자로써 SQL의 쿼리 작성을 편리하게 돕기 위한 
 라이브러리이다. ORM은 생산성을 위해서도 사용되지만, 사용자의 입력값을 라이브러리 단에서
 알아서 escape하고 쿼리에 매핑시키기 때문에 안전하기 SQL쿼리를 사용할 수 있다.

[Command Injection]

-웹 어플리케이션에서 OS Command를 사용하기 위해 PHP(system),Node JS(child_process),
 Python(os,system)과 같이 OS command를 실행하는 함수가 구현되어 있다. OS Command란 linux(ls,pwd,ping)등..
 windows(dir,pwd,ping)등 OS에서 사용되는 Command이다.

-일반적으로 웹 어플리케이션에서 OS Command를 사용하는 이유는 이미 기능을 구현한
 OS실행 파일이 존재할 때 코드 상에서 다시 구현하지 않고 OS Command로 실행하면
 더 편리하기 때문임.

-OS command는 내부적으로 쉘을 이용해 실행하는데, 쉘에는 한 줄에 여러 명령어를 실행하는
 등의 사용자 편의를 위해 제공하는 특수문자들이 존재한다. OS command를 사용할 때,
 사용자의 인풋이 검증되지 않고 그대로 OS command함수에 들어가면 다음과 같은 특수문자를 이용해서
 사용자가 원하는 명령어를 실행할 수 있음.

※echo는 주어진 문자열을 다시 출력반환하라는 뜻이다.
--------------------------------------------------------------------------
``
:명령어 치환; ``안에 들어있는 명령어를 실행한 결과로 치환됩니다.
--------------------------------
$ echo `echo theori`
theori
----------------------------------

$()
:명령어 치환; $()안에 들어있는 명령어를 실행한 결과로 치환됩니다.
이 문자는 위('')와 다르게 중복 사용이 가능합니다. (echo $(echo $(echo theori)))
------------------------------------
$ echo $(echo theori)
theori
-----------------------------------

&&
:명령어 연속 실행;한 줄에 여러 명령어를 사용하고 싶을 때 사용합니다. 
 앞 명령어에서 에러가 발생하지 않아야 뒷 명령어를 실행합니다. (Logical And)
-----------------------------------------------------------
$ echo hello && echo theori
hello
theori
-----------------------------------------------------------

||
:명령어 연속 실행; 한 줄에 여러 명령어를 사용하고 싶을 때 사용합니다. 
 앞 명령어에서 에러가 발생해야 뒷 명령어를 실행합니다. (Logical Or)
-------------------------------------------------------------
$ echo hello || echo theori
hello
theori
---------------------------------------------------------------
;
:명령어 구분자; 한 줄에 여러 명령어를 사용하고 싶을 때 사용합니다.
 ;은 단순히 명령어를 구분하기 위해 사용하며, 
 앞 명령어의 에러 유무와 관계 없이 뒷 명령어를 실행합니다.
----------------------------------------------------------------
$ echo hello ; echo theori
hello
theori
------------------------------------------------------------

|
:파이프(piping); 앞 명령어의 결과가 뒷 명령어의 입력으로 들어갑니다.
--------------------------------------------------------------
$ echo id | /bin/sh
uid=1001(theori) gid=1001(theori) groups=1001(theori)
-------------------------------------------------------------

2-9



