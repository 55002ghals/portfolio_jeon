-C언어에서 발생할 수있는 메모리 커럽션 취약점 중 버퍼 오버플로우,
 Out-of-Boundary,Off-by-one에 대해 자세히 알아보도록 하자.

[버퍼 오버플로우]

-C언어에서 버퍼란 지정된 크기의 메모리공간이라는 뜻이다. 

-버퍼 오버플로우 취약점은 그 이름에서 나타나듯이 버퍼가 허용될 수
 있는 양보다 더 많은 값이 저장되어 버퍼가 넘치는 취약점이다.

-일반적으로 버퍼 오버플로우는 발생하는 위치에 따라서 스택 버퍼 오버플로우,
 힙 오버플로우와 같이 나눠서 부른다. 버퍼 오버플로우는 인접한 메모리를
 오염시키는 취약점이기 때문에 어떤 메모리를 오염시킬 수 있는지에
 따라 공격 방법이 달라지기 때문이다.
-------------------------------------------------------------------------------------
e.g)

-8바이트의 버퍼A와 8바이트 데이터 버퍼 B가 선형적으로(연속하여) 메모리에 
 할당되었다고 하자. 여기서 버퍼 A에 16바이트의 데이터를 복사한다면
 이 데이터의 뒷부분은 버퍼 A를 넘어 뒤에 있는 데이터 영역인 B에 쓰여지게 된다.

-이때 우리는 버퍼 오버플로우가 발생했다고 하고, 이는 프로그램의 Undefined Behavior(*)
 을 이끌어낸다. 만약 데이터 영역B에 나중에 호출될 함수 포인터를 저장하고 있다면 이값을
 "AAAAAAAA"와 같은 데이터로 덮었을 때, Segmentation Fault(**) 를 발생 시킬 것이다. 만약
 공격자가 이를 악용한다면, 어딘가에 기계어 코드를 삽입한 후 함수 포인터를 공격자의 코드의
 주소로 덮어 코드를 실행할 수도 있다.

*정의되지 않은 동작; 런타임 중에 어떤 현상이 발생할지 예측할 수 없다는 뜻
**접근 권한이 없는 메모리 영역을 읽거나 쓰려고 할때 발생하는 예외
-----------------------------------------------------------------------------------------


[스택 버퍼 오버플로우]

-그중 스택 버퍼 오버플로우는 가장 초기에 연구되었던 형태의 버퍼 오버플로우이다.
 지역 변수가 할당되는 스택 메모리에서 오버플로우가 발생하는 경우이다.
---------------------------------------------
// stack-1.c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
    char buf[16];
    gets(buf);
    
    printf("%s", buf);
}
----------------------------------------------

-위 stack-1.c코드는 16바이트 버퍼 buf를 스택에 할당한 후, 
 gets함수를 통해 사용자로부터 데이터를 입력받아 그대로 출력하는 함수이다.

-gets함수는 사용자가 개행(Enter)을 입력하기 전까지 입력했던 모든 내용을 
 첫번째 인자로 전달된 버퍼에 저장하는 함수이다. 그러나 gets함수에는
 별도의 길이제한이 없기 때문에 16바이트가 넘는 데이터를 입력한다면 
 스택 버퍼 오버플로우가 발생한다.

-이처럼 버퍼 오버플로우 취약점은 프로그래머가 버퍼의 길이에 대한
 가정을 올바르게 하지 않아 발생한다. 이는 보통 길이 제한이 없는 API
 함수를 사용하거나 버퍼의 크기보다는 입력받는 데이터의 길이가 더 크게 될때
 자주 일어나는 실수이다.

*API: OS와 프로그램 사이에 존재하며 함수,루틴,프로토콜로 구성되어 프로그램과
       운영체제 사이의 중간에서 작용을 한다.

-----------------------------------------------------
// stack-2.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int check_auth(char *password) {
    int auth = 0;
    char temp[16];
    
    strncpy(temp, password, strlen(password));
    
    if(!strcmp(temp, "SECRET_PASSWORD"))
        auth = 1;
    
    return auth;
}
int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: ./stack-1 ADMIN_PASSWORD\n");
        exit(-1);
    }
    
    if (check_auth(argv[1]))
        printf("Hello Admin!\n");
    else
        printf("Access Denied!\n");
}

*ctrncpy함수: C언어; string number copy; 문자열을 복사하는 함수이다. strcpy는 다르게 뒤에 하나의 인자를 더 받는데, 이는 
	     strncpy(char* dest, const char* origin, num)에서 origin의 문자열을 dest에 num번 칸까지 복사하라는 의미이다.
(crtcpy함수는 string copy; 문자열을 복사하는 함수이다. 2개의 인자를 가지며 뒤에 있는 문자열을 앞 문자열에 복사해 넣는다는 뜻이다.)

*strlen함수:C언어; string length; 문자열의 길이를 반환함, 이때 10짜리 문자열을 선언하여 5칸만 채웠다면 strlen은 5를 반환한다.

*strcmp함수: C언어; string comparing; 문자열의 비교결과를 반환, 두 문자열이 같으면 0을 반환함.
	     ASCII코드 기준으로 앞쪽이 더 크면 1을, 뒷쪽이 더 크면 -1을 반환함.
(strncmp는 뒤에 하나의 인자를 더 받으며 그 번째의 문자를 ASCII코드 기준으로 비교하라는 의미임)

------------------------------------------------------

->stack-2.c의 main함수에서는 argv[1]을 check_auth함수의 인자로 전달한 후 그 리턴값을 받아온다.
   리턴값이 0이면 Hello admin을 출력하고 아니면 Access Denied!를 출력한다.

->check_auth 함수에서는 16바이트 크기의 temp버퍼에 입력받은 패스워드를 복사한 후 
   "SECRET_PASSWORD"문자열과 비교한다(strcmp 이용)  두 문자열이 같으면 auth값을 1로 설정하고
   그 값을 반환한다.

-> 그러나 여기서check_auth함수에서 strncpy함수를 통해 temp버퍼에 복사할 때 temp의 크기인 16바이트가아닌
    password문자열의 길이만큼 복사한다. 따라서main 함수에서 check_auth의 인자로 들어오는 
    argv[1]에 16바이트가 넘는 문자열이 전달된다면 길이 제한 없이 문자열이 모두 복사되어
    스택 버퍼 오버플로우가 발생한다.
(※반복해서 복사하고 또 복사한다는 의미가 아니라 password의 크기만큼을 복사해 넣는다는 의미의 반복이다.
    즉, 딱 password의 크기만큼을 temp에 복사해 넣겠다는 의미.)

----------------------------------------------------------------------
// stack-3.c
#include <stdio.h>
#include <unistd.h>
int main(void) {
    char win[4];
    int size;
    char buf[24];
    
    scanf("%d", &size);
    read(0, buf, size);
    if (strncmp(win, "ABCD", 4)){
        printf("Theori{-----------redeacted---------}");
    }
}

*read함수: c언어; 열린 파일(open함수로 열음)을 읽을때 씀
	read(fd,buf,num); 에서 fd라는 파일을 buf에 저장하되 num 바이트 까지만 수신하라는 의미임.
	이때, 0이면 그 값을 사용자로부터 입력받아야함.
----------------------------------------------------------------------

-> stacl-3.c의 main함수는 24바이트 크기의 버퍼buf를 할당한다.
    scanf함수를 통해 size변수에 값을 입력받고, size만큼 buf에 데이터를
    입력 받는다.

->stack-1.c에는 길이검증이 없는 함수를 사용해 스택 버퍼 오버플로우가 발생했다면 이번엔
   고정된 크기의 버퍼보다 더 긴 데이터를 입력받아 버퍼 오버플로우가 발생했다.

-> buf가 24바이트짜리 버퍼이므로, size의 값이 24보다 크면 오버플로우가 발생하게 된다.

----------------------------------------------------------------------
// stack-4.c
#include <stdio.h>
int main(void) {
	char buf[32] = {0, };
	read(0, buf, 31);
	sprintf(buf, "Your Input is: %s\n", buf);
	puts(buf);
}

*sprintf함수: sprintf(s1, "Hello %s", s2);
	     ->sprintf는 출력함수가 아니라 문자열을 저장하는 함수이다.
 	     ->위 sprintf함수의 의미는 s1에 "Hello %s"를 %s는 s2를 지정해서
	        저장하라는 뜻이다. 
		(s2에 "World!"라는 문자열이 들어있었다면 s1에는 "Hello World!"가 저장됬을 것이다.)

------------------------------------------------------------------------

->위 read함수에서는 buf버퍼에 들어갈 바이트수에 31이라는 한계를 부여해
   스택 버퍼 오버플로우를 막은 것 같지만 아래 sprintf함수에서 buf에 추가적으로
   "Your Input is:"이라는 문자열이 더해지면서 31-14인 17바이트 이상의 문자열을
   buf에 담아오면 스택 버퍼 오버플로우가 발생하게 된다.

-지금까지 살펴본 봐와 같이 버퍼 오버플로우는 프로그래머가 길이에 대한 
 검증을 수행하지 못해 발생한다.

-만약 공격 벡터로부터 데이터를 입력받고 이를 버퍼에 저장하는 코드가 있다면
 이를 유심히 살펴볼 필요가 있다. 프로그래머는 데이터를 버퍼에 입력받을 때 입력받는 
 데이터가 버퍼의 범위를 초과하지 않는지 항상 검사해야 한다.

-입력받을 때 길이 제한이 없는 함수를 사용한다면 이는 잠재적으로 취약하다고 볼 수 있다.
 만약 길이를 명시하는 함수를 사용한다면, 명시된 길이가 버퍼의 크기를 넘을 수 있을 지를
 검토해야 한다.

-버퍼 오버플로우는 스택에서만 발생하는 취약점이 아니다. 프로그래머가 
 동적으로 메모리를 관리할 수 있는 힙에서도 똑같이 발생한다. 이들은 단지
 발생하는 메모리 영역의 차이만 있을 뿐이고 취약점이 발생하는 원인이
 본질적으로 다르지 않다.


[힙 오버플로우]

-힙 영역은 스택 영역과 사용 목적이 다르기 때문에, 스택 버퍼 오버플로우와는 다른 방법으로
 익스플로잇 해야한다. 그 고정은 리눅스 익스플로잇에서 다뤄야하므로 이번엔 간단한 발생 원인만
 알아보도록 하자.

---------------------------------------------------------------------------
// heap-1.c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
    char *input = malloc(40);
    char *hello = malloc(40);
    
    memset(input, 0, 40);
    memset(hello, 0, 40);
    
    strcpy(hello, "HI!");
    read(0, input, 100);
    
    printf("Input: %s\n", input);
    printf("hello: %s\n", hello);
}

*malloc: C언어; memory allocation; 메모리를 할당해줄때 쓴다. malloc함수의 인자로 할당할
	메모리 공간의 크기를 넣어준다.

*memset: 어떤 메모리의 시작점부터 연속된 범위를 어떤 값으로
	모두 지정하고 싶을때 사용하는 함수이다.
	위의 memset(input,0,40);은 input이라는 메모리에 0이라는
	값으로 40바이트만큼의 메모리를 채우라는 말이다.
--------------------------------------------------------------------------
->heap-1.c는 40바이트 짜리 힙 버퍼 input과 hello를 할당한 후,
   hello버퍼에는 "Hi!"문자열을 복사하고 read함수를 통해 input에
   데이터를 입력받는 코드이다.

->그러나 raed 함수를 통해 입력받는 길이인 100바이트가 input버퍼의
   크기인 40바이트봐 크기 때문에 힙 오버플로우가 발생한다.

[Out-Of-Boundary]

-버퍼의 길이 범위를 벗어나는 인덱스에 접근할 때 발생하는 취약점이다.
--------------------------------------------------------------------
// oob-1.c
#include <stdio.h>
int main(void) {
    int win;
    int idx;
    int buf[10];
    
    printf("Which index? ");
    scanf("%d", &idx);
    printf("Value: ");
    scanf("%d", &buf[idx]);
    printf("idx: %d, value: %d\n", idx, buf[idx]);
    if(win == 31337){
        printf("Theori{-----------redeacted---------}");
    }
}
----------------------------------------------------------------------
->위  oob-1.c에 주의해야 할 점은 buf의 길이가 10이므로 buf의
   인덱스로 사용 될 수 있는 올바른 값은 0이상 10 미만의 정수라는
   사실이다. 그러나 코드에서는 idx값을 입력 받을 때 해당 값이 올바른
   범위에 있는지 검사하지않는다.

-c언어에는 인덱스를 이용해 버퍼에 접근할 때 인덱스의 범위에 대한 별도의
 경계 검사가 존재하지 않기 때문에 올바르지 않는 값을 사용한다면
 buf의 영역밖의 값에 접근할 수 있다.

※자꾸 헷갈려해서 써두는데 인덱스는 0부터 시작한다는거 잊지말자.


----------------------------------------------------------------------
// oob-2.c
#include <stdio.h>
int main(void) {
    int idx;
    int buf[10];
    int win;
    
    printf("Which index? ");
    scanf("%d", &idx);
    
    idx = idx % 10;

    printf("Value: ");
    scanf("%d", &buf[idx]);
    printf("idx: %d, value: %d\n", idx, buf[idx]);
    if(win == 31337){
        printf("Theori{-----------redeacted---------}");
    }
}
----------------------------------------------------------------------

->oob-2.c는 oob-1.c와는 달리 idx를 입력받는 코드(어떤인덱스의 값을 조정할 건지 입력)
   에 idx = idx % 10; 가 추가되었다. 이걸로 OOB를 막을수 있을까?

-OOB의 발생 여부를 판단할 때는 버퍼의 인덱스로 사용할 수 있는 올바른 값의
 범위와 버퍼의 인덱스가 될 수 있는 모든 값의 범위를 비교하면 된다.

*buf의 인덱스로 써야하는 값의 범위: 0~9
*buf의 인덱스로 쓸수 있는값의 범위: (int형의 범위)%10

-얼핏보면 같아보이지만 피연산자가 음수라면 연산의 결과도 음수가 될 수 있다.
 따라서 이 경우 buf의 인덱스로 쓸 수 있는 값의 범위는 -9부터 9이므로
 나머지가 음수가 되게 하면 OOB가 발생할 수 있다.

※몰랐던 사실: 인덱스 지정시, 음수를 하면 해당 메모리에서 1바이트 앞에 있는 메모리로
                    접근할수 있다.

-------------------------------------------------------------------------
//oob-3.c
#include <stdio.h>
int main(void) {
    int idx;
    int buf[10];
    int dummy[7];
    int win;
    printf("Which index? ");
    scanf("%d", &idx);
    
    if(idx < 0)
        idx = -idx;
    idx = idx % 10; // No more OOB!@!#!
    printf("Value: ");
    scanf("%d", &buf[idx]);
    printf("idx: %d, value: %d\n", idx, buf[idx]);
    if(win == 31337){
        printf("Theori{-----------redeacted---------}");
    }
}
-----------------------------------------------------------------------

->OOB-3.c는 절댓값 연산을 위한 if문으로 완벽히 OOB를 막은 것 같다.

- 하지만 C언어의 정수표현에 대해 생각해 보면 뭔가 이상한 부분이 있다는 것을
  알 수 있다.

-다음은 절댓값으로 변환하기위한 if문에 입출력 변화이다.
------------------------------------------------
idx = 1 (line 14) -> idx = 1 (line 15)

idx = -100 (line 14) -> idx = 100 (line 15)

idx = -10000 (line 14) -> idx = 10000 (line 15)

idx = -pow(2, 31) (line 14) -> idx = -pow(2, 31) (line 15)

-------------------------------------------------

-c언어에서 int형 정수의 범위는 -pow(2, 31) ~ pow(2, 31) - 1이다.

-int형은 32비트이기(4바이트) 때문에 총 pow(2,32)개의 수를 표현 할 수 있다.
 int형은 0을 포함하기 때문에 표현할 수 있는 음의 정수의 갯수와
 양의 정수의 갯수가 다르다. (0이 없으면 둘다 데칼코마니 ㄱㄴ)

-int형에서 -pow(2,31)은 표현 가능하지만 pow(2,31)은 표현 불가능하다.
 이는 표현가능 최대 정수보다 하나 크기 때문이다. 때문에, pow(2,31)을
 int형 메모리에 저장하려고 하면 -pow(2,31)로 저장된다.(한바퀴 뺑 돔)(@)

-다시 OOB-3.c를 보자. 지금까지에 따르면 idx에 -pow(2,31)을 넣으면
 절댓값 연산이 있더라도 -2^31이 저장된다. 그렇다면 idx에 음수가 저장되고,
 이는 buf배열의 올바른 인덱스 범위를 벗어나기 때문에 OOB가 발생한다.

-이를 막기 위해선 근본적으로 idx를 unsigned int로 선언하거나 
 인덱스를 입력받은 이후 if(idx < 0 || idx >= 10) 같은 경계 검사 구문을
 추가해야 한다.

※pow(2,31)=2,147,483,648

//질문 1) 정수형 변수 idx에 값이 이미 표현 불가능한 값인데 거기서 10의 나머지를
             구하는 연산에서 에러가 나지 않았는가?
	A) 표현 불가능한 값이므로 뺑 돈다, 덤프값이 되는게 아님!(@참고)
  질문 2) 인터렉티브 창을 통해 -pow(2,31)보다 더 작은 값을 넣었더니
             잘 되지 않았다. 그렇다면 해당 코드에서의 OOB는 -pow(2,31)을 넣었을 때만 일어나는가?
	A) 정수를 저장할 때 음수 한계나 정수 한계에 다다르면 반대쪽으로 넘어간다.(@참고)

[Off-By-One]

-One-by-one 취약점은 경계 검사에서 하나의 오차가 있을 때 발생하는
 취약점이다. 이는 버퍼의 경계 계산 혹은 반복문의 횟수 계산 시 < 대신 <=을
 쓰거나, 0부터 시작하는 인덱스를 고려하지 못할때 발생한다.

------------------------------------------------
// off-by-one-1.c
#include <stdio.h>
void copy_buf(char *buf, int sz) {
    char temp[16];
    
    for(i = 0; i <= sz; i++)   //Off-by-one 발생!
        temp[i] = buf[i];
}
int main(void) {
    char buf[16];
    
    read(0, buf, 16);
    copy_buf(buf, sizeof(buf));
}
------------------------------------------------
-> 위 off-by-one-1.c에서는 반복문에서 i가 0일때부터 sz일때 까지
   총 sz+1번 반복하게 되며, 따라서 sz+1만큼 데이터가 복사되고, 
   off-by-one 취약점이 발생하게 된다.

요약(사이트 내용 그대로 북붙)

스택 버퍼 오버플로우
:스택 버퍼 오버플로우는 가장 초기에 등장한 버퍼 오버플로우 형태 중 하나로, 
 지역 변수가 할당되는 스택 메모리에서 발생하는 취약점입니다. 
 이는 데이터를 입력받거나 복사하는 부분에 대한 길이 검증이 존재하지
 않거나 미흡할 경우에 발생합니다.

힙 오버플로우
:힙 버퍼 오버플로우는 동적으로 할당된 힙 메모리 영역에서 발생하는 
 취약점입니다. 이는 데이터를 입력받거나 복사하는 부분에 대한 길이
 검증이 존재하지 않거나 미흡할 경우에 발생합니다.

Out-Of-Boundary
:Out-Of-Boundary는 버퍼의 길이 범위를 벗어나는 인덱스에 접근할 때
 발생하는 취약점입니다. 이는 올바르지 않은 값이 버퍼의 인덱스로 
 사용될 경우 발생합니다.

Off-by-one
:Off-by-one은 버퍼의 경계 계산 혹은 잘못된 반복문의 연산자를 
사용하는 등의 인덱스를 고려하지 않을 때 발생하는 취약점입니다.
