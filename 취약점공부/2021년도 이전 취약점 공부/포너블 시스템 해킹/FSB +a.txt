FSB추가 

Memory Corruotion에서 FSB파트 1-4/4에 실습문제.

-printf("buf");와 같은 형식에서 buf값에 포맷 스트링이 들어가면
 FSB가 발생하는데.

-이때, 포맷 스트링의 %x, %d 같은 포맷 스트링은 주소값이 없으면
 '다음 메모리 4바이트를 참조하여'출력하게 되어있다.

※
%x: 정수를 16진수로 변환해서 출력하라는 포맷 스트링

-메모리 스택의 맨 아래부터 참조하는데 그렇다면 메모리 맨 처음부터
 buf값 사이에 무슨 값이 있을지 확인하기 위해서 %x|%x|%x|...를 반복해서 처보자.
----------------------------------------------------------------
bash3.2$ ./fsb1
input : %x|%x|%x|%x|%x|%x|%x|%x|%x|%x
1|41fe41ff|42be4242|0|257c7825|78257c78|7c78257c|257c7825|78257c78|7c78257c
Failed
---------------------------------------------------------------

-우리가 buf에 넣은 값은 '%x|'의 반복이다. 이때, '%x|'는 16진수로
 25787c이다. 뭔가 눈에 보이지 않는가?

-1|41fe41ff|42be4242|0| 까지가 buf전 인 것이다.

-페이지에서는 printf_stackframe이라는 메모리라고 하는데 잘 모르겠다. 아무튼 이런게 있다고한다.

-여기서 FSB의 핵심인 %n 포멧 스트링을 보도록 하자.

%n: 
이 포맷 스트링을 마주치면 다음에 해당하는 4바이트 메모리를 참조하여
해당 4바이트에 들어있는 값을 주소로 인식하여 해당 포맷 스트링을 만나기 전까지
출력된 바이트 수의 크기를 해당 주소에 입력함.
----------------------------------------------------
e.g)
그말인 즉슨  %14x%n이라고 해두면 %n을 만나는 순간 그 다음 4바이트에 데이터를 주소로 알고 참조하여
14를 집어 넣는다는 의미이다.
-----------------------------------------------------

-엄청난 것이다. 원하는 주소에 원하는 값을 넣을 수 있다니!

-그렇다면 원하는 주소와 원하는 값은 어떻게 지정할 수 있을까?

1.%n이 주소로 참조하는 4바이트의 위치를 예상해 그 곳에 원하는 주소를 넣어놓으면 된다.

2.%n으로 집어넣을 값은 출력된 바이트수 이므로, 출력하는 바이트 수를 조절하면 된다.

-우리는 '%x|'를 마구 넣어 봄으로써 16바이트 이후에 buf가 할당하는 메모리가 시작됨을 알았다.
 그렇다면 buf에 시작부에 우리가 값을 넣을 주소를 넣은 후 %n으로 하여금 그 주소를 참조하게 해보자.

※그 전에 목표 주소를 알아두자,
 auth의 시작주소는 16진수로 fffdd030이다(앞에 0x는 16진수라는 의미이니 뺴도록 하자.)
 이는 아스키 코드로 ÿýÐ0이다(Hex decode). 이 것을 %n의 참조 주소로 넣어주자.

-우리가 넣어야할 값은 C언어 코드를 보건데 0xff값이다. 이는 10진수로 255이다.
 즉 %n이전에 출력해야할 바이트의 수는 255바이트라는 의미이다.

-이때, %(num)x 또는 %(num)c 같이 포맷 스트링 사이에 정수를 끼워넣으면 이는
 "num만큼의 바이트크기로 해당 포맷스트링을 출력하라" 라는 뜻이다.
 %16x는 16바이트의 크기로 %x포맷스트링의 결과가 출력된다.

-이를 이용하여 %n이전의 출력 바이트수가 255바이트가 되며, %n이 참조하는
 4바이트 주소가 시작 이후로 16바이트를 지나 17~20번째 바이트가 되도록 
 공격 페이로드를 짜보자.

-우선 auth의 주소를 buf의 맨 앞칸에 넣자.
 이때, %n은 little-endian방식으로 메모리에 값을 저장하므로 
 0Ðýÿ로 주소값을 뒤집어 넣어주어야한다.

※little-endian방식: 메모리에 저장되는 방식을 규정한 것중 하나로
		리틀 앤디안 방식은 레지스터에 있는 16진수 값의 
		4바이트가 뒤집혀서 들어간다. 
		e.g) register) 0A0B0C0D
			->memory)0D0C0B0A

-그리고 %x를 4번 진행하여 %n이 참조하는 4바이트가 
 buf의 맨 첫 바이트가 되도록 하자
 
0Ðýÿ%x%x%x%x%n

-이제 0Ðýÿ(auth)에 들어갈 바이트 수를 조정하면 되겠다.

 ※ %x는 원래 8바이트짜리여서 만일 %6x도 그냥 8바이트라고한다.

0Ðýÿ%8x%8X%8x%227x%n
 
-위와 같이 짜면 0Ðýÿ=4바이트
	         %8x =8바이트*3
	         %227X=227바이트
		=225바이트 

-이렇게 공격 페이로드가 완성되었다. 한번 실행해보겠다.
---------------------------------------------------------------------------
bash3.2$ ./fsb1
input : 0Ðýÿ%8x%8X%8x%227x%n
0Ðýÿ       141FE41FF42be4242                                                                                                                                                                                                                                  0
Success!!
----------------------------------------------------------------------------

-아름답다ㅠㅠ



