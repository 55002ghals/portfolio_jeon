[Format String Bug(FSB)]

-FSB는 printf나 sprintf와 같이 포멧 스트링을 사용하는 함수에서 발생하는 취약점으로,
 %s나 %x와 같이 프로그래머가 지정한 문자열이 아닌 사용자의 입력이 포멧
 스트링으로 전달될 때 발생하는 취약점이다.

-printf(buf); 와 같이 사용자의 입력이 printf함수의 인자로 그대로 전달될 때를 생각해보자.
"asdf"같은 일반적인 문자열이 전달된다면 그 문자열이 그대로 출력될 것이다.
 그러나 %s나 %x와 같은 포멧 스트링이 들어간다면 이는 인자를 전달하지 않고 포맷 스트링을
 전달한 것과 같은 효과가 된다. 포맷 스트링 버그는 이처럼 검증되지 않은 사용자의 입력이
 포멧 스트링으로 취급되어 Undefined Behavior를 일으키는 버그이다.

------------------------------------
// fsb-1.c
#include <stdio.h>
int main(void) {
    char buf[100] = {0, };
    
    read(0, buf, 100);
    printf(buf);
}
------------------------------------

-fsb-1.c는 char형 배열buf에 100바이트를 입력받고 printf함수를 통해
 입력받은 버퍼를 출력하는 간단한 예제이다.

-만약 "asdf"나 "10"같은 간단한 문자열을 입력한다면 printf문은 정상적으로 
 문자열을 출력할 것이다.

-그러나 "%x %s"와 같은 포맷 스트링을 문자열로 입력한다면, printf(buf);는 printf("%x %s");가 된다.
 이는 printf("%x %s");에 두,세번째 인자가 전달되지 않으므로 쓰래기값을 인자로 출력합니다.

%s %d라고 buf값을 입력하면 다음과 같이 출력된다.

bf3977c0 100


-----------------------------------------------------------
// fsb-2.c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
    FILE *fp = fopen("log.txt", "w");
    char buf[100] = {0, };
    
    read(0, buf, 100-1);
    
    fprintf(fp, "BUFFER-LOG: ");
    fprintf(fp, buf);
    
    fclose(fp);
    return 0;
}

*fprintf(FILE* stream,const char*format,...);
	->...에는 형식이 들어감, format을 형식에 맞추어 stream에 쓴다.
----------------------------------------------------------
-> fsb-2.c는 fprint함수에서 포멧스트링 버그가 발생하는 코드이다.
    fprint함수의 두번째 인자는 포멧스트링이여야 한다.

->그러나 fsb-2.c에서는 포멧스트링이 위치할 곳에 사용자의 버퍼가 위치하므로 
   포멧스트링 버그가 발생하게된다.

-fsb-1.c와 마찬가지로 %x나 %d와 같은 포멧 스트링을 입력하면 의도치 않은 값이
 파일에 저장된다.

------------------------------------------------------------------
// fsb-2.c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
    FILE *fp = fopen("log.txt", "w");
    char buf[100] = {0, };
    
    read(0, buf, 100-1);
    
    fprintf(fp, "BUFFER-LOG: ");
    fprintf(fp, buf);
    
    fclose(fp);
    return 0;
}
-------------------------------------------------------------------

-fprintf의 두번째 인자는 포맷 스트링이어야 한다. 그런데 fp스트림에 buf를 넣는 fprintf문에서
 포맷 스트링이 위치할 곳에 사용자의 버퍼(buf)가 위치하므로 
 포멧 스트링 버그가 발생하게 된다.

[mitigration]

-포멧 스트링 버그는 포멧 스트링을 사용하는 함수의 인자만 잘 검토하면 되기 때문에
 다른 취약점들에 비해 막기 쉽다. 특히 최신 컴파일러에서는 포맷 스트링으로 전달되는
 인자가 문자열 리터널이 아닐 경우 경고메세지를 출력하기 때문에 최근에는 거의 발생하지 않는 취약점이다.

-표준 C라이브러리에서 포멧 스트링을 사용하는 대표적인 함수들은 
 다음과 같다.

printf
sprintf / snprintf
fprintf
vprintf / vfprintf
vsprintf / vsnprintf

-위 와같은 포멧 스트링을 주의 깊게 보자. 혹시 검증되지 않은 입력 포멧이 스트링으로 전달 되는가?

[1-4 마지막 예제 못풀었다. C언어 스택에 대해 공부하고 %n에 대해 
 공부한 뒤에 다음 사이트를 보고 추가적으로 공부하자.
 https://shayete.tistory.com/entry/5-Format-String-Attack-FSB 
 https://geundi.tistory.com/124]


[Double-free & Use After free]

-C언어는 프로그래머가 수동으로 동적 메모리를 관리해야 한다.

-이번 장에는 올바르지 않은 동적 메모리 관리로 인해 발생하는 취약점을
 알아보도록 하자.

-동적 메모리 관리에서 가장 자주 발생하는 문제는 해제된 메모리를 정확히
 관리하지않아 발생하는 문제이다. 특히 Double Free 취약점은 이미 
 해제된 메모리를 다시 한 번 해제하는 취약점이다. 또, Use-After-Free(UAF) 취약점은
 해제된 메모리에 접근해서 값을 쓸 수 있는 취약점입니다.

-------------------------------------------------------------------
// df-1.c
#include <stdio.h>
#include <malloc.h>
int main(void) {
    char* a = (char *)malloc(100);
    char *b = (char *)malloc(100);
    memset(a, 0, 100);
    strcpy(a, "Hello World!");
    
    memset(b, 0, 100);
    strcpy(b, "Hello Pwnable!");
    
    printf("%s\n", a);
    printf("%s\n", b);
    
    free(a);
    free(b);
    
    free(a);
}
-----------------------------------------------------------------------
->df-1.c는 메모리를 할당하고 할당된 메모리에 Hello World!문자열을
   복사한 뒤 이를 출력하는 코드이다. 그러나 마지막에 a를 두번 헤제하는
   실수를 범한다.

->하지만 해당 프로그램은 우분투18.04환경에서 실행시 정상적으로 종료된다는
   것을 알 수 있다. 따라서 line12에서 이미 free된 메모리a에 대해 다시 free를
   호출하는 일이 어떤 일을 발생시키는지 정확히는 모르지만 이미 해제된 메모리를
   다시 해제하는 것이 불가능하지는 않다는 사실을 알 수 있다.

-> 위의  char* a = (char *)malloc(100); 코드에서 a가 저장하고 있는 값은
   특정 힙 메모리의 주소이다. 그러므로 a가 free 했을 때 시스템에 해당하는 힙 메모리
   할당자의 구현에 따라 메모리가 해제된다.

-이때 같은 포인터의 해제가 두번 일어나는 것과같은 비정상 적인 일은
 공격자로 하여금 프로그램을 예상치 못한 실행으로 이끌어 갈 수 있도록 해준다.

==================================================
****※ 간단히 보는 힙, 데이터, 스택

-프로그램을 구성하는 메모리 공간은 3개의 영역으로나누어 진다.
 스택,힙,데이터 영역이다.

-프로그램이 실행되면 할당되며, RAM에 할당된다.

1.데이터 영역

-전역변수와 static변수가 할당되는 영역 

2.스택 영역

-함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 영역
-함수 호출이 완료되면 사라짐.

3. 힙 영역

-필요에 의해 동적으로 메모리를 할당할 때 사용한다.

-할당해야할 메모리의 크기를 프로그램이 실행되는 동안에 결정해야 하는 경우 유용하게
 사용된다. (malloc, calloc realloc 등 사용)
===============================================

[Use After Free(UAF)]
--------------------------------------------------------
// uaf1.c
#include <stdio.h>
#include <string.h>
#include <malloc.h>
int main(void) {
    char *a = (char *)malloc(100);
    memset(a, 0, 100);
    
    strcpy(a, "Hello World!");
    printf("%s\n", a);
    free(a);
    
    char *b = (char *)malloc(100); 
    strcpy(b, "Hello Pwnable!");
    printf("%s\n", b);
    
    strcpy(a, "Hello World!");
    printf("%s\n", b);
}
---------------------------------------------------------
->uaf1.c에서 a라는 메모리를 100바이트의 크기로 할당 후에 
   "Hello World!"라는 문자열을 복사한다. 현재 힙 메모리의 상태는
   아래와 같다.
--------------------------------------------
{Heap Memory}
  (H)(e)(l)(l)(o) (W)(o)(r)(l)(d)(\0)
  ㄴ(여기가 포인터 a의 시작주소!)
--------------------------------------------
-그리고 free(a)로 메모리 a를 해제하고 새로운 100바이트짜리 메모리b를 할당한다.
 이때 중요한 점은 포인터 a에 저장된메모리 주소는 변하지 않았으며 
 메모리 a와 메모리b가 가르키는 주소는 같다는 것이다.

-이는 a가 메모리할당자로 들어가고, 새로운 메모리 영역을 할당할때(b) 
 메모리를 효율적으로 관리하기 위해 기존에 해제되었던 메모리가 그대로 반환되어
 일어나는 일이다.

※해제한다고 해서 해당 메모리 할당자를 쓰지 못하는게 아닌가보다..

-그러므로 이미 해제된 메모리 a에 접근하면 메모리 b가 같이 영향을 받기 때문에
 프로그래머가 의도하지 않은 일이 발생할 수 있다.

-strcpy(b, "Hello Pwnable!");에서 메모리 b의 주소에 넣고서 
 strcpy(a, "Hello World!"); 에서 다시한번 a를 불러오는데, 이때 a의 주소는
 b와 같으므로 최종적으로 힙 메모리는 다음과 같다.

{heap memory}
 (H)(e)(l)(l)(o) (W)(o)(r)(l)(d)(!)(\0)
  ㄴ메모리a와 메모리b의 주소!

-결국 포인터 a에 "Hello World!"문자열을 복사하고 
 메모리 b를 출력하면 Hello World!가 출력된다. 

-메모리 할당자는 환경에 따라 다르지만 일반적으로 효율성을 위해 이미
 해제된 메모리를 재사용하게 된다. 이때 해제된 메모리 포인터에
 데이터를 쓴다면, 이미 다른 곳에서 사용되고 있는 메모리에 데이터가 작성될 수 있다.
 이를 이용해 의도되지 않은 동작을 발생시키는 취약점을 UAF라고 한다.

-프로그램의 규모가 커지거나 구조가 복잡해질수록 UAF취약점은 생각치도 못한 곳에서
 발생하곤한다. 특히 여러 컴포넌트들이 결합된 형태의 프로그램은 더욱 그렇다.

-가령 두 컴포넌트가 서로 상호작용하며 프로그램이 동작하는 경우, 한 컴포넌트에서 객체나
 메모리의 사용이 끝났다고 판단해 해제했지만 다른 컴포넌트에서는 이 내용이
 동기화되지 않아 그 포인터를 그래도 사용할 수도 있다.

[초기화되지 않은 메모리]

-C언어와 C++에서는 수많은 구조체들과 클래스들을 선언하고
 이들의 인스턴스(*)들을 만들어낸다.

*인스턴스: 실제로 컴퓨터의 저장공간에 클래스의 구조로 할당된 실체를 의미함.

-변수를 선언하거나 인스턴스를 생성할 때는, 프로그래머가 의도하 경우를 제외하고는
 반드시 초기화해야한다. 메모리를 초기화하지 않는다면 쓰레기 값이 들어가게 되고,
 이는 프로그램의 흐름을 망가트릴 수 있다.

-공격자가 메모리를 정교하게 조작해서 초기화되지 않은영역에 공격자의 입력이 들어갔다고 치자.
 이는 보안 취약점으로 이어질 것이다.

----------------------------------------------------------------
// uninit1.c
typedef struct person {
    char *name;
    int age;
} Person;
int main(void) {
    Person p;
    int name_len;
    
    printf("Name length: ");
    scanf("%d", &name_len);
    
    if(name_len < 100)
        p.name = (char *)malloc(name_len);
    read(0, p.name, name_len);
    
    printf("Age: ");
    scanf("%d", &p.age);
    
    printf("Name: %s\n", p.name);
    printf("Age: %d\n", p.age);
}
---------------------------------------------------------------

->unint1.c의 구조체 Person은 char*형 변수 name과 int형 변수 age를 맴버 변수로 가진다.

->main 함수에서는 Person의 인스턴스를 선언 후, name의 길이를 name_len변수에 입력받는다.
   만약 길이가 100보다 작으면 malloc함수를 통해 메모리를 할당한 후 name_len만큼 입력받는다.
   그러나 이 코드에서는 초기화되지 않은 값의 사용으로 인해 두가지 문제점이 발생한다.

->우선 name에 할당된 메모리를 초기화하지 않는다는 것이다.
   read함수는 입력받을 때 널 바이트와 같은 별도의 구분자를 붙이지 않는다.
   따라서 이후 name을 출력하는 부분에서 초기화되지 않은 다른 메모리가 출력될 수 있다.

->두 번째는 name_len 변수의 값이 100보다 클때의 예외처리가 없다는 것이다. 이 경우 p.name은
    malloc으로 할당된 값이 아니라 쓰레기 값이 된다. 만약 공격자가
    이 값을 조적할 수 있다면 read문(line 16)을 통해 데이터를 입력받을 때 
    원하는 메모리 주소에 원하는 값을 쓸 수 있게 된다.

[Integer issues; 정수의 범위]

-C,C++언어를 사용할 때 자주 발생하는 취약점중 하나는 정수의 형 변환을 제대로 고려하지않아
 발생하는 취약점이다.
 
-특히 정수의 범위에 대한 정확한 이해없이 작성된 코드는 자주 문제를 일으키는데, 이는 때로 
 치명적인 취약적을 발생시킬 수 있다. 따라서 먼저 C언어의 정수 자료형이 표현할 수 있는 범위를
 정확히 알아야한다.
-------------------------------------------------------------
자료형에 따른 표현가능범위)
char: -2^7~2^7-1
unsigned char: 0~2^8-1

short: -2^15~2^15-1
unsigned short: 0~2^15-1

int: -2^31~2^31-1
unsigned int: 0~2^32-1

longlong: -2^63~2^63-1
unsigned longlong: 0~2^63-1
-------------------------------------------------------------

->size_t와 long의 자료형은 아키텍쳐에 따라 표현할 수 있는 수의 범위가
   달라진다.

-long자료형은 32비트인 경우 int와 동일하고 64비트인 경우 longlong과 동일하다.
 size_t자료형은 32비트일때 unsigned int와 동일하고 64비트일 때눈 unsigned long과 같다.

[묵시적 형 변환]

-연산 시 연산의 피연산자로 오는 데이터의 자료형이 서로 다를경우,
 형 변환이 일어나게 된다. 이때 프로그래머가 자료형을 직접 명시하지 않으면
 묵시적 형 변환이 일어난다.

-프로그래머가 이런 형 변환에 대해 정확히 숙짛지 못한다면 이는 취약점으로 이어질 수 있다.

--------------------------------------------------------------
묵시적 형 변환의 규칙)

-대입연산의 경우 대입연산자의 좌변과 우변의 자료형이 다를경우 묵시적 형 변환이 일어나게 된다.
 작은 정수 자료형에 큰 정수를 저장하는 경우 작은 정수의 크기에 맞춰
 상위 바이트가 소멸된다.

-정수승격은 char나 short같은 자료형이 연산될 때 일어난다. 이는 컴퓨터가 int형을 기반으로
 연산하기 때문에 일어난다.

-피연산자가 불일치할 경우 형 변환이 일어난다. 이 결우
 int > long > longlong > float > double >long double
 순으로 변환되며 작은 바이트에서 큰 바이트로, 정수에서 실수로 형 변환이 일어나게 된다.
 예를 들어 int와 double을 더하면 int가 double 형으로 변환된 후 연산이 진행되게 된다.
----------------------------------------------------------------

-------------------------------------------------
// int-1.c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
    char *buf;
    int len;
    
    printf("Length: ");
    scanf("%d", &len);
    
    buf = (char *)malloc(len + 1);
    
    if(!buf) {
        printf("Error!");
        return -1;
    }
    
    read(0, buf, len);
}
----------------------------------------------------
->위 코드에서 len에 -1을 넣는다면 buf칸에는
   0바이트의 메모리가 할당되게 되면서 buf = (char *)malloc(len + 1);문은
   정상 작동하게 된다. 이후 read문에서 len 값은 -1이므로,
   read(0,buf,-1); 가 호출되게 된다. 그런데 이때 read함수의 3번째 인자는
   size_t형이므로 묵시적 형 변환이 일어나게 된다.

*위에도 써있지만 size_t형 변수는 32비트 아키텍쳐에서 unsigned int와 같은 용량을 가진다.

-결국 32비트 아키텍쳐라 가정하면 해당 코드는 다음과 같이 호출된다.
 read(0,buf,pow(2,32)-1);

-그러므로 지정된 크기의 버퍼를 넘는 크기의 데이터를 넣을 수 있어 
 힙 오버플로우가 발생한다.(*할당된 메모리 크기는 0이다.)

-----------------------------------------------------
// int-2.c
char *create_tbl(unsigned int width, unsigned int height, char *row) {
	unsigned int n;
	int i;
	char *buf;
	n = width * height;
	buf = (char *)malloc(n);
	
	if(!buf)
		return NULL;

	for(i = 0; i < height; i++)
		memcpy(&buf[i * width], row, width);
	return buf;
}
------------------------------------------------------
-> int-2.c의 create_tb1함수는 width,height값과 초기화 데이터인
   row포인터를 인자로 받고 테이블을 초기화한다.

-buf = (char *)malloc(n);에서 width * height만큼의 메모리를
 buf에 할당한 후 각 행에 init_row데이터를 복사하게 된다.

-하지만 width,height,n이 전부 unsigned int형의 변수이기 때문에
 width*height가 pow(2,32)를 넘어가면 의도하지 않은 값이 들거가게 된다.
 두 수의 pow(2,32)를 넘는 수를 가져 buf값에 그 크기를 감당하지 못하는
 작은 값의 메모리가 할당되었다고 쳐도 아래 반복문에서 width와 height의
 크기가 pow(2,32)를 넘어가지만 않는다면 정상 진행되므로 버퍼 오버플로우가 발생하게 된다.

----------------------------------------------------
char *read_data(int fd) {
	char *buf;
	int length = get_int(fd); // length는 사용자가 입력할 수 있는 값입니다.
	if(!(buf = (char *)malloc(MAX_SIZE))) // #define MAX_SIZE 0x8000
		error("malloc: %m");
	if(length < 0 || length + 1 >= MAX_SIZE) {
		free(buf);
		error("bad length: %d", value);
	}
	if(read(fd, buf, length) <= 0) {
		free(buf);
		error("read: %m");
	}
	
	buf[length] = '\0';
	return buf;
}
-----------------------------------------------------
->바로 위 코드는 if문에서 길이검사를 하게되는데, 이때
   length에 0x7fffffff(=pow(2,31)-1)을 넣게 되면
  if(length < 0 || length + 1 >= MAX_SIZE)
  첫번째 length<0은 통과하고 
  두번째 length+1은 -pow(2,31)이 되므로 통과하게 된다.
  그러므로 결국 read문에서 read(fd,buf,0xfffffff)가 호출되어
  힙 오버플로우가 발생하게 된다.
  (char형 포인터인 buf에 0xfffffff만큼의 데이터를 fd를 통해 넣을 수있게됨)















