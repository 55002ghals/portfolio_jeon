 bandit.labs.overthewire.org:2220

[bandit0]

ls
현재 위치의 파일 목록을 조회하는 명령어
---------------------------------------------------------
-l :파일들의 상세정보를 나타냄
-a: 숨어있는 파일을 표시함
-F: 파일의 마지막에 유형을 나타내는 파일명을 표시함
-

***-al: -l 과 -a를 같이 나오게 하는거임("ls -al" :: 왠만하면 이거 씀)
-> 중요한건 이런식으로 겹쳐서 옵션을 적용시킨다는 점임!! 
-----------------------------------------------------------

cd
디렉토리 이동
------------------------------------------------------------
~:홈 디렉토리로 이동
.: 상위 디렉토리로 이동
-: 이동 직전 디렉토리로 뒤로가기
------------------------------------------------------------
mkdir ***
디렉토리 생성(***을 이름으로 함)

cp
파일 복사
boJ9jbbUNNfktd78OOpsqOltutMc3MY1

mv
파일 이동시킴

rm
파일 제거

cat
파일의 내용을 화면에 출력하거나 파일로 저장

*cat read1 read2 ->이렇게 쓰면 한번에 2개 이상의 파일을 출력가능

rediraction
화면에 출력되는 결과를 파일로 저장

file
파일의 종류를 확인할때 사용

du
현재 디렉토리 혹은 지정한 디렉토리의 사용량을 확인할때 사용

find
원하는 조건의 파일,디렉토리를 검색할 수 있음
---------------------------------------------------------
[bandit1]

Ctrl+C :현재 진행중인 작업 종료, 바로 INPUT줄로 돌아온다.

: -는 stdin, stdout 등으로도 쓰이므로, 파일 명에 '-'가 쓰일때는 구분이 필요하다.
 우리가 말하려는-가 다른 것이아닌 파일의 이름이라는 것을 cat이라는 명령어가
 알아듣게 해야하는데, 그러기 위해선 "-가 현재 디렉토리 안에 있는 -이라는 파일이야!"
 라고 해야한다. "cat ./-" 이라고 하면된다.
("."은 현재 디렉토리를 의미)

*** 원도우, 리눅스 통합 복붙방법:
     -복사: Ctrl+Ins
   -  붙여넣기: Shift+ Ins

[bandit2]
: 보면 알겠지만 리눅스에서 특수문자나 띄어쓰기를 파일이름에 넣지 말자.
 이젠 어떡할까? 파일이름에 띄어쓰기가 있다. 띄어쓰기는 앞에 역슬래쉬를 붙임으로써 
 cat명령어에게서 숨길 수(?)있다.

"cat spaces\ in\ this\ filename"이 답이다.

*****개중요 팁: 탭은 리눅스에서 지원하는 자동 이름 완성 기능이다.
  	       이는 물론 띄어쓰기나 슬래쉬때문에 cat이 제대로 기능하지 못하는
	       경우가 없도록 고려하여 자동완성을 해준다.
	       "cat s"까지만 쓰고 탭을 눌러보자, 와 놀라워라!

[bandit3]

*** 숨겨진 파일은 앞에 .을 붙여서 지명한다.
    그래서 hidden이라는 파일을 ls -al 을 통해 발견 했다면 
    그것을 보기 위해선 cat .hidden 이라고 해야한다.

[bandit4]
답: koReBOKuIDDepwhWk7jZC0RTdopnAYKh

나의 답: Ctrl+Insert키를 통한 반복으로 "file ./-file00"을 반복함 0부터 10까지
            모두 data형식이였지만(cat하면 읽지못함) ASCII Text인 07파일을 발견.
            cat ./-file07 하니까 답나옴.

풀이: file ./* 

-"*"은 와일드 카드 문자로써 "str*"이라고 대상을 지칭하면 이름이 str으로 시작된 모든 디렉토리, 파일을
 동시에 지칭할 수 있다. 이때, 아무것도 없이"*"을 쓴다면, 해당 디렉토리의 모든 디렉토리, 파일을 지칭하게 된다.
  e.g) file ./* ->현재 디렉토리 내의 모든 파일에 대해 file 실행

[bandit 5]
답:DXjZPULLxYr17uwoI01bNLQbtFemEgo7

-여기서는 find에 대해 공부하는 것임.

-find는 파일 및 디렉토리를 검색하는 명령어이다.

-find는 옵션식과 표현식이 많은 편이다. 알아두자 유용하다.
     ->표현식이 훨신 많이 쓰인다고 한다.

--------------------------------------------------------------------------
find [OPTION...] [PATH] [EXPRESSION...]

      OPTION
        -P        : 심볼릭 링크를 따라가지 않고, 심볼릭 링크 자체 정보 사용.
        -L        : 심볼릭 링크에 연결된 파일 정보 사용.
        -H        : 심볼릭 링크를 따라가지 않으나, Command Line Argument를 처리할 땐 예외.
        -D        : 디버그 메시지 출력.

      EXPRESSION
        -name     : 지정된 문자열 패턴에 해당하는 파일 검색.
        -empty    : 빈 디렉토리 또는 크기가 0인 파일 검색.
        -delete   : 검색된 파일 또는 디렉토리 삭제.
        -exec     : 검색된 파일에 대해 지정된 명령 실행.
        -path     : 지정된 문자열 패턴에 해당하는 경로에서 검색.
        -print    : 검색 결과를 출력. 검색 항목은 newline으로 구분. (기본 값)
        -print0   : 검색 결과를 출력. 검색 항목은 null로 구분.
        -size     : 파일 크기를 사용하여 파일 검색.(byte단위는 c로 쓴다 "-size 1024c"이런 식으로)
        -type     : 지정된 파일 타입에 해당하는 파일 검색.
        -mindepth : 검색을 시작할 하위 디렉토리 최소 깊이 지정.
        -maxdepth : 검색할 하위 디렉토리의 최대 깊이 지정.
        -atime    : 파일 접근(access) 시각을 기준으로 파일 검색.
        -ctime    : 파일 내용 및 속성 변경(change) 시각을 기준으로 파일 검색.
        -mtime    : 파일의 데이터 수정(modify) 시각을 기준으로 파일 검색.
-----------------------------------------------------------------------------------

-아무 옵션,표현식 없이 find만 사용한다면 현재 
 디렉토리 내에 있는 모든 디렉토리와 그 하부 디렉토리의 
 모든 파일과 디렉토리를 보여준다.

find 표현식 사용법:
-find 적고 어디서 찾아볼지(. or /)적고 표현식 쓰기

-find . -name "str*"
   -> 현재 디렉토리(.)에서 str로 시작된 이름을 가진 모든 파일을 찾아달라

-find / -size 4c
  -> root 디렉토리(/)에서 즉, 전체 시스템에서 4kbyte의 크기를 가진 파일을 찾아달라

...그 외 다양한 응용가능

[bandit6]
답:HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs

-find의 추가적인 표현식을 사용한다.

-꼭 ls -al시 나오는 파일이 아디더라도 서버 어딘가에 있는 파일은 다 볼 수 있다.

-user: 유저가 누구인지를 표현식으로 써넣을 수 있다.
-group: 그룹소유가 누구인지 표현식으로 써넣을 수 있다.

-"2>/dev/null"
:"/dev/null"은 휴지통을 뜻하며 2는 STRERR(standard error)로 표준에러를 의미한다.
 즉, 이는 표준에러 메세지는 휴지통에 넣어 버리라는 의미이다.

-find / -user bandit7 -group bandit6 -size 33c 2>/dev/null
 이라 치면 나온다.

[bandit7]
답: cvX2JJa4CFALtqS87jk27qwqGhBM9plV

-grep 명령어: 입력으로 전달된 파일의 내용에서 특정 문자열을 찾고자 할때
                   사용하는 명령어이다.(많이 사용됨)

-grep [OPTION...] PATTERN [FILE...]의 꼴을 가짐.
------------------------------------------------------------------------------
옵션:
        -E        : PATTERN을 확장 정규 표현식(Extended RegEx)으로 해석.
        -F        : PATTERN을 정규 표현식(RegEx)이 아닌 일반 문자열로 해석.
        -G        : PATTERN을 기본 정규 표현식(Basic RegEx)으로 해석.
        -P        : PATTERN을 Perl 정규 표현식(Perl RegEx)으로 해석.
        -e        : 매칭을 위한 PATTERN 전달.
        -f        : 파일에 기록된 내용을 PATTERN으로 사용.
        -i        : 대/소문자 무시. **
        -v        : 매칭되는 PATTERN이 존재하지 않는 라인 선택.
        -w        : 단어(word) 단위로 매칭. **
        -x        : 라인(line) 단위로 매칭. **
        -z        : 라인을 newline(\n)이 아닌 NULL(\0)로 구분.
        -m        : 최대 검색 결과 갯수 제한.
        -b        : 패턴이 매치된 각 라인(-o 사용 시 문자열)의 바이트 옵셋 출력.
        -n        : 검색 결과 출력 라인 앞에 라인 번호 출력.
        -H        : 검색 결과 출력 라인 앞에 파일 이름 표시.
        -h        : 검색 결과 출력 시, 파일 이름 무시.
        -o        : 매치되는 문자열만 표시.
        -q        : 검색 결과 출력하지 않음.
        -a        : 바이너리 파일을 텍스트 파일처럼 처리.
        -I        : 바이너리 파일은 검사하지 않음.
        -d        : 디렉토리 처리 방식 지정. (read, recurse, skip)
        -D        : 장치 파일 처리 방식 지정. (read, skip)
        -r        : 하위 디렉토리 탐색.   **
        -R        : 심볼릭 링크를 따라가며 모든 하위 디렉토리 탐색.
        -L        : PATTERN이 존재하지 않는 파일 이름만 표시.
        -l        : 패턴이 존재하는 파일 이름만 표시.
        -c        : 파일 당 패턴이 일치하는 라인의 갯수 출력.
---------------------------------------------------------------------------------

-목적어 예시

1. *: 현재 디렉토리의 전체 파일에서 검색 

2.*.ext: 특정 확장자를 가진 모든 파일에서 문자열 검색(.txt .jpg 같은거)

[bandit 8]
답:  UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR

[bandit8에 나오는 읽기 자료 정리]
=====================================================
[data stream]

-모든 프로그램은 세가지 data stream이 연결된 명령 라인에서 운용된다.

*STDIN(0): standard Input(프로그램에 들어가는 data)
*STDOUT(1): standard Output(프로그램에 의해 출력되는 값;터미널에서)
*STDERR(2): standard error(에러 메세지;또한 터미널에서)

[Redirecting to a File]

-우리는 output이 스크린에 출력되길 일반적으로 원하지만, 때때로 이것을 
 저장하여 다른 시스템에 입력하거나 하기를 원할 수 있다. 우향 꺾새기호(>)
 는 결과를 출력하는것 대신 파일에 저장하는 명령어 이다.

예시)

user@bash: ls       //바로 출력되는 ls
barry.txt bob example.png firstfile foo1 video.mpeg
user@bash: ls > myoutput    // 꺾새기호를 이용해서 output값을 myoutput이라는 파일에 저장
user@bash: ls
barry.txt bob example.png firstfile foo1 myoutput video.mpeg
user@bash: cat myoutput     //아까 만든 myoutput(ls 의 output저장)을 읽음
barry.txt
bob
example.png
firstfile
foo1
myoutput          // 위 실행의 결과로 생긴 파일
video.mpeg        

-이미 있었던 파일의 이름을 가져와 >을 실행하면, 덮어쓰기가 된다.
 즉, 원래 있던 파일은 없어짐.

-이때 꺾새 기호를 2개 써서 덮어쓰기가 아닌 붙여넣기가 가능함.
---------------------------------------------------------------
예시)

user@bash: cat myoutput
7 barry.txt         //원래 myoutput 내용
user@bash: ls >> myoutput  //더블 꺾새를 이용한 ls의 output 불여넣기
user@bash: cat myoutput
7 barry.txt
barry.txt
bob
example.png
firstfile
foo1
myoutput
video.mpeg      //원래 myoutput에 이어 ls의 output이 추가된 모습
user@bash:
----------------------------------------------------

[Redirecting from a File]

-좌향 꺾새를 이용하면 오른쪽의 파일로부터 데이터를 가져와 왼쪽의 프로그램에 넣을 수 있다.
 (STDIN stream을 통해서)
-------------------------------------
예시)

user@bash: wc -l myoutput
8 myoutput
user@bash: wc -l < myoutput
8
user@bash:

* wc :저정한 파일의 행,단위,문자수를 세는 프로그램
 ->형식은 wc [옵션] [파일이름]
 ->옵션은 다음과 같다.
         -l:  행
         -w: 단어
         -c:  문자
--------------------------------------
-위 예시를 보면 myoutput이라는 파일을 통한 wc시행을 2번 실행한다.
 보이다시피 아래는 redirecting을 이용한 실행이다. 여기까지만 보면 굳이 redirecting을 쓸
 명분이 없다싶다. 하지만 두 차이는 그 결과값에 myoutput이라는 문자열이 나왔냐 안나왔냐에서
 있다. 

-첫번째 wc 실행에서, wc는 myoutput이라는 파일에서 직접 연산값(행 개수)를 받게된다. 
 그러므로, wc입장에서 그 출처를 알기 때문에 파일의 이름도 함께 출력한다.
 하지만 두번째 redirecting을 이용하면 wc는 연산값의 출처를 알지 못한다.
 즉, 출처를 알지 못하므로 파일 이름을 출력할 수 없다. 

-이는 부수적인 데이터(필요하지 않은 데이터)를 출력되지 못하도록 하는 데에 유용하게 쓰인다.

-위의 >와 <을 보면 다음과 같은 응용도 가능하다.
--------------------------------------------------------
user@bash: wc -l < barry.txt > myoutput     //barry.txt를 redirecting해서 실행한 wc값을 myoutput에 저장!
user@bash: cat myoutput
7
user@bash:
---------------------------------------------------------------
->redirecting이 "<"보다 우선시 된다는 걸 알 수 있다(직관 적으로도 앞에 있음)

[Redirecting STDERR]

-STDERR은 숫자 2로써 나타내지며, 이는 이 stream을 지칭하기 위해 사용된다.
 만일 우리가 숫자를 좌향 꺾새(>) operator앞에 둔다면, 이는 그 숫자가 나타내는 stream을 나타내는 것이다.
 (만일 이전처럼 아무것도 안쓰고 꺾새만 쓴다면, 이는 default값인 stream1(STDOUT)으로 처리된다.)

-------------------------------------------------------------------
예시)

user@bash: ls -l video.mpg blah.foo
ls: cannot access blah.foo: No such file or directory  //STDERR발생
-rwxr--r-- 1 ryan users 6 May 16 09:14 video.mpg
user@bash: ls -l video.mpg blah.foo 2> errors.txt    //이전과 같은 실행이지만 그 출력값중 2(STDERR)를 errors.txt 저장
-rwxr--r-- 1 ryan users 6 May 16 09:14 video.mpg
user@bash: cat errors.txt                                    //STDERR를 저장한 errors
ls: cannot acces blah.foo: No such file or directory

--------------------------------------------------------------------

-만일 출력값과 함께 STDERR도 같이 파일에 저장하고 싶으면 어떻게할까.

-우선 output을 error.txt에 저장한다. 이때, STDERR를 그 output에 포함시키면 되지 않겠는가?
      ->이때 왜 그냥 바로 output 을 저장할때 STDERR는 저장되지 않는가 하면,
          output은 STDOUT(1)에 속해서 >앞에 default로 생략된 1에 들어가지만, STDERR(2)는 안되기 때문이다.

-즉, 다음과 같이 진행한다.
----------------------------------------------------------------------
user@bash: ls -l video.mpg blah.foo > myoutput 2>&1     //STDOUT을 myoutput에 저장, STDERR를 STDOUT을 의미하는 &1에 넣는다.
user@bash: cat myoutput
ls: cannot access blah.foo: No such file or directory
-rwxr--r-- 1 ryan users 6 May 16 09:14 video.mpg
user@bash: 
-----------------------------------------------------------------------

-이때 ">"의 저장파일이 되는 STDOUT은 이를 의미하는 1앞에&를 붙여서 지칭한다.
 이는 1이라는 파일으로 인식되는 일을 피하기 위함이다.

[piping]
-지금까지 데이터를 파일로 또는 파일에서 보내는 것만 다뤘다면, 지금부터는 
 데이터를 프로그램에서 그리고 프로그램으로 보내는 매커니즘을 다뤄보겠다.

-piping이라고 하는 오퍼레이터는 기호 "|" 를 사용하고. 이 오퍼레이터의 역할은
 왼쪽의 프로그램에서의 결과값을 오른쪽의 프로그램의 입력값으로 넣어주는 것이다.
 

-이 예시에는 디렉토리 안의 파일중 처음 3개의 파일만을 출력할 것이다.
-------------------------------------------------------------------------------

user@bash: ls
barry.txt bob example.png firstfile foo1 myoutput video.mpeg
user@bash: ls | head -3
barry.txt
bob
example.png
user@bash:

*head명령어: 파일의 앞부분을 확인하는 명령어이다.
**tail명령어: 파일의 뒷부분을 확인하는 명령어이다.

-n num
 :num수 만큼 출력해준다.

-c num
 :num byte만큼 출력해준다.

-q
 :여러개의 파일을 출력할 때 제목을 출력하지 않는다.

-f
 :내용이 변경될 때마다 실시간으로 출력해준다.
  ->로그파일 모니터링 등에 활용. (tail만 있음)

e.g) head -n 3 readme.txt
    ->이렇게 하면 앞부분부터 3줄까지만 출력하라는 뜻이다.
---------------------------------------------------------------------------------

-더불어, 우리는 많은 프로그램을 함께 piping할 수 있다.

-아래 예시는 output 을 tail에 piping하여서 3번째 파일에만 볼 수 있도록 한 것이다.
--------------------------------------
user@bash: ls | head -3 | tail -1    //ls의 ouput을 head실행에 piping, 이러면 3줄짜리 output, 이 것을 다시 tail에 piping, 결국 한줄짜리(3번째 줄) 값을 출력
example.png
user@bash: 
---------------------------------------

※우리가 프로그램에 제공하는 어떤 명령어든지 그 명령어는 프로그램옆에 있어야한다.

※많은 이들이 실수하는 것은 piping을 쭉 짜놓고서는 어디선가 잘못된 piping line을 발견하게 된다는 것이다.
  piping line을 쭉 짤때, 항상 자신이 옳은 결과값이 piping 되는지 |를 쓰기전에 확인하는 습관을 들이자.
  이것은 많은 좌절을 절약시켜줄 것이다.

-아래처럼 piping 과 redirection을 같이 쓸 수도 있다.
---------------------------------------------------------------
user@bash: ls | head -3 | tail -1 > myoutput
user@bash: cat myoutput
example.png
user@bash: 
---------------------------------------------------------------

[복습겸 예시들]

1. 이 예시에서는 디렉토리를 sort하여 모든 디렉토리들이 처음에 정렬되도록 하였다.
------------------------------------------------------------------------
user@bash: ls -l /etc | tail -n +2 | sort            // /ect 디렉토리의 ls -l의실행 STDOUT을 tail에 piping 하여 이를 sort에 piping
drwxrwxr-x 3 nagios nagcmd 4096 Mar 29 08:52 nagios
drwxr-x--- 2 news news 4096 Jan 27 02:22 news
drwxr-x--- 2 root mysql 4096 Mar 6 22:39 mysql
...
user@bash: 

*sort명령어: ASCII코드 순서(abcd...,1234...)로 파일을 정렬해서 출력한다.
                 이때, 필드(음절)는 default로 첫 음절의 아스키 코드값의 순서로 정렬하며,
	    "sort +1 readme.txt"이와 같이 쓰면 두번째 음절을 이용한 실행이 가능하다.
---------------------------------------------------------
sort 옵션:

-n 
라인의 각 필드를 비교하는 대상을 숫자로 한정 

-f   
영어를 정렬할 때, 대소문자 구별안함 

-r    
출력 순서를 역순으로 

-b    
앞에 붙는 공백 무시

-t     
필드 구분자 지정

-m   
정렬된 파일을 병합

-u    
정렬후, 중복행 제거(중복된 얘들은 하나만 출력하는 것임)

-o    
저장할 파일명을 명시, 명시하지 않으면 화면에 출력
---------------------------------------------------------------------

출처: https://linuxmadang.tistory.com/entry/linux리눅스-sort-명령어 [리눅스마당]

**/ect와 /usr/ect 디렉토리에는 시스템의 부팅, 셧다운시에 필요한 파일들, 
  시스템의 전반에 걸친 설정 파일들 및 초기 스크립트 파일들이 있다.
--------------------------------------------------------------------------

2.여기서는 프로그램의 OUTPUT을 less에 넣어 실행했다.
---------------------------------------------------------------------
user@bash: ls -l /etc | less
(결과값은 직접 해보삼 ㅇㅇ)

*less 명령어: more은 위에서 아래로 이동하면서 읽을 수 있지만 
	    more은 아래에서 위로 또한 이동 가능하다. 
	    화살표 ,Pgup,PgDn이 작동한다. 나가기 위해선 q를 눌러야한다.
**more 명령어: 긴파일을 읽을 때 사용한다. cat와 비슷하지만, 파일을 다 읽고 나면 출력 내용이 유지되지 않고 사라진다.
		-> 출력 결과가 긴 파일을 끊어 읽을때 piping을 통해
		    "ls -al /ect | more"와 같이 활용한다.
------------------------------------------------------------------------

3. 홈 디렉토리(~)에 모든 파일중에서 그룹이 쓰기원한을 가진 파일을 확인한다.
----------------------------------------------------------------------------
user@bash: ls -l ~ | grep '^.....w'   //~에서 ls 실행 output을 grep에 piping
drwxrwxr-x 3 ryan users 4096 Jan 21 04:12 dropbox
user@bash: 

* 여기서 '^...w'를 쓰면 왜인지 모르겠지만 그룹이 쓰기원한을 가진 파일으로 치부되는듯.
----------------------------------------------------------------------------

4. 주어진 디렉토리 안의 파일을 소유했던 모든 유저들의 리스트를 만들고
    또한 몇번이나 그들이 그 파일이나 디렉토리를 소유했었는지 출력.
------------------------------------------------------------------------------
user@bash: ls -l /projects/ghosttrail | tail -n +2 | sed 's/\s\s*/ /g' | cut -d ' ' -f 3 | sort | uniq -c
8 anne
34 harry
37 tina
18 ryan
user@bash: 
 
*sed(stream editor)명령어: grep과 비슷하게 필터이지만, 이 명령어는 파일을 수정할 수 있게 하는
                           반면 ed처럼 대화식 처리는 불가능하다. sed는 1개 라인씩 입력 라인을 읽어
                           표준출력으로 출력한다.
		->ed "file name" 명령어: filename의 내용을 수정할 수 있는 명령어이다. (자세한건 구글링)
		-> 둘이 비슷한것 같은데 좀 명령어가 복잡한듯.. 구글링해서 꼭 직접 해보기.

**cut 명령어: 파일에서 필드를 뽑아낸다. 필드는 구분자로 구분할 수 있다.
	->필드(field): 데이터를 처리하는 최소단위를 말함.(구글링 ㄱㄱ 어렵다)
-------------------------------------------------------------------
-c '문자위치' 
:잘라낼 곳의 글자 위치를 지정한다. 콤마나 하이픈을 사용하여 범위를 정할 수도 있으며, 이런 표현들을 혼합하여 사용할 수도 있다.

-f '필드' 
:잘라낼 필드를 정한다.

-d '구분자' 
:필드를 구분하는 문자를 지정한다. 디폴트는 탭 문자다.

-s 
:필드 구분자를 포함할 수 없다면 그 행은 하지 않는다.
------------------------------------------------------------------------------

***uniq명령어: 파일 내용을 출력시 해당 행과 바로 앞 행을 비교하여 같은 행이라면 출력하지 않습니다.
-----------------------------------------------------------------------------
옵션:

-c 
: 몇번이나 중복되서 나오는지 파일명 앞에 숫자로 출력합니다.

-d 
: 중복되어 나오는 라인 중 한 열만 출력합니다.

-D 
: 중복되는 모든 열을 출력합니다.

-u 
: 중복 열이 없는 것만 출력합니다.
--------------------------------------------------------------------------------
========================================================
 
[풀이]
user@bash: sort data.txt | uniq -c  

-sort를 이용해서 data내의 행들을 아스키코드 오름차순으로 정렬함.

-이것을 uniq실행에 파이핑시킴으로써 쉽게 중복된 행을 알아냄
	(보통 두개는 무조건 같이 씀!!)

[bandit 9]

답:truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk


*strings 명령어: 프로그램(파일) 안에서 출력 가능한 문자열을 출력해준다.

bandit9@bandit:~$ ls -l     //디렉토리 내 파일 확인
total 20
-rw-r----- 1 bandit10 bandit9 19379 Oct 16  2018 data.txt
bandit9@bandit:~$ strings data.txt | grep '='           //data.txt에서 출력 가능한 문자만 솎아 낸 것을 grep에 파이핑
2========== the
========== password
>t=     yP
rV~dHm=
========== isa
=FQ?P\U
=       F[
pb=x
J;m=
=)$=
========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk   //빙고!
iv8!=
bandit9@bandit:~$


[bandit10]
답:IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR

-base64란 8비트 이진데이터(실행파일이나 ZIP파일)를 문자코드에 영향을 받지 않는
 공통 ASCII영역의 문자들로 이루어진 문자열로 바꾸는 인코딩 방식을 가르킴.

-base64명령어는 문자열을 base64로 언코드 혹은 디코드 해주는 명령어임
---------------------------------------------
base62 [옵션] [파일명]

디폴트 값
base64 인코딩

 -d
base64디코드, 디폴트 값

-i
디코딩할때, 알파벳만 출력

-w
COLS문자 뒤에 줄바꿈
-----------------------------------------------

풀이:

bandit10@bandit:~$ ls -l       //췤
total 4
-rw-r----- 1 bandit11 bandit10 69 Oct 16  2018 data.txt
bandit10@bandit:~$ file data.txt           
data.txt: ASCII text
bandit10@bandit:~$ cat data.txt     
VGhlIHBhc3N3b3JkIGlzIElGdWt3S0dzRlc4TU9xM0lSRnFyeEUxaHhUTkViVVBSCg==
bandit10@bandit:~$ cat data.txt  | base64 -d         //data.txt를 base64디코딩
The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR  //빙고!
bandit10@bandit:~$

[bandit11]

답:5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu

-rot 13이란 알파벳이 abcd..순으로 했을 때 13칸 더 가서 쓰인 암호화를 말함.
 예를 들어 A(1)는 N(13)으로 가는 것임.


*tr명령어: 지정한 문자를 바꾸어주거나 삭제하는 명령어 
-------------------------------------------------------------
e.g)
cat readme.txt | tr '[a-z]' '[A-Z]'
  ->readme의 소문자를 모두 대문자로 바꿔달라는 명령어(아래보면 알겠지만 '[]'필요없음)

cat test | tr -d . 
  -> test의 점을 모두 없애달라는 명령어
---------------------------------------------------------------

풀이:

cat data.txt | tr a-zA-Z n-za-mN-ZA-M
The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu

//솔직히 존나 이해 안간다 저게 왜 저런 코드가 나오는지 구글링해도 이해가 안간다.

[bandit12]
답:  8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL

*hexdump: 램 또는 파일이나 저장장치에 있는 컴퓨터 데이터의 16진법적인 보임새이다.
	  보통 디버깅이나 리버스 엔지니어링의 한 부분이다.

**xxd명령어: 주어진 파일이나 STDIN으로 들어온 문자들에 대해서 hex dump를 만들어 준다.

	-제일 좌측에는 파일의 상대주소가 나옴
	-제일 우측에는 ASCII형태로 각 바이트의 값들을 보여줌
옵션:
-b : bit로 표시해줍니다.
-e : 우측에 나타나는 값들이 ASCII가 아닌 EBCDIC로 합니다.

--------------------------------------------------------------------------
***압축하기/압축 풀때 사용하는 명령어들

1. gzip명령어: 뒤에 확장자 gzip을 붙여서 한다.
---------------------------------------------------------
bandit12@bandit:/tmp/CRR$ file data8.bin   //data8.bin의 파일 형태 확인
data8.bin: gzip compressed data, was "data9.bin", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix
//gzip형식으로 압축되었다는 것과, 안쪽에 data9.bin이 있다는것 확인
bandit12@bandit:/tmp/CRR$ mv data8.bin data8.bin.gz  //압축을 풀기위해 확장자 변경(mv로 이름변경 실행)
bandit12@bandit:/tmp/CRR$ gzip -d data8.bin.gz    //gzip실행으로 압축풀기.
------------------------------------------------------------

-> 어떤 파일을 gz로 압축한다면 다음과 같이 사용한다.
gzip readme.txt

-> 압축을 풀기 위해서는 -d 옵션을 사용한다.
gzip -d readme.gz

2.gzip2명령어: gzip과 동일하나, 확장자로는 gz2가 붙고, 명령어는 gzip2이다, 옵션은 동일.

3.tar명령어: 명령어와 확장자 모두 tar이다. 위gzip과는 다른 압축풀기 옵션을 사용한다.

bandit12@bandit:/tmp/testman$ file data6.bin // data6.bin의 압축 방식 확인
data6.bin: POSIX tar archive (GNU) //tar압축파일임을 확인
bandit12@bandit:/tmp/testman$ mv data6.bin data6.bin.tar  //확장자 지정(mv이용)
bandit12@bandit:/tmp/testman$ tar -xvf data6.bin.tar   //-xvf옵션을 이용해서 압축을 품
data8.bin

[옵션]
-xvf 
: 압축풀기
----------------------------------------------------------------
[풀이(중요!)]

********중요사항: 이진파일(binary file)은 모든 실행파일을 구성한다.
	          그런데, 그런 이진 파일이 16진수로 되어었다면(Hext dump)
	          이를 열거나 압축하거나 풀거나 하기 위해선(실행파일로 만들기 위해선)
	          이를 이진파일로 만들어야한다.

-bandit12에는 특이하게 home(~)에 권한이 없다. /tmp 아래에 파일을 하나 만든후 
 그곳으로 cp명령어를 이용해 디렉토리를 복사후 진행한다.

-data.txt는 16진수 Hexdump이므로 이를 바이너리 파일로 변환하자.

-xdd에 -r옵션을 사용하는 것이 그 방법 되겠다.
 (xdd 디폴트로는 바이너리 파일을 16진수로 바꾸는 것이다, 그러나 -r 옵션은 그 역순이다.)

-그 이후에는 file (나온 파일 이름) 으로 압축 형태 파악하고,
 그에 맞추어서 압축을 해제하는 일만 반복하면 된다.

[bandit13]

답:4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e.

[SSH]

-리눅스 서버를 구축한다면 터미널이나 그래픽 유저 인터페이스 환경을 통해
 여러가지 작업을 진행할 수 있다. 이때, 서버와 관리자가 물리적으로 멀다면
 서버작업을 처리할 때마다 서버 위치로 이동하기 힘들 것이다.

-이때 원격접속은 필수적이며, 이러한 원격접속을 이용하여 터미널 환경을
 사용할 수 있도록 고안된 프로토콜이 Telnet과 SSH등이 있다.

-SecureShell의 약자이며 기본 22번 port를 사용한다. 기본 암호화 방식을 지원하며
 중간에 해킹을 당해서 원본을 알 수 없다. 보안적으로 우수함.

[SSH명령어]

형태는 ssh [userid]@[ip address or domain]  [option]

-----------------------------------------------------------
옵션:

-a	
인증 에이전트 전송을 불허

-e	
세션에 대한 이스케이프 문자를 설정

-f	
인증과 전송이 설정된 후에 백그라운드에서 ssh를 설정

-l	
원격 시스템에 사용할 로그인 이름을 설정

-p	
원격 호스트에 연결할 포트를 지정

-v	
디버깅모드 자세한 정보 표시 모드를 활성

-x	
X11 전송을 불가능하게 설정

-L	
지정된 원격 호스트와 포트에 전송할 로컬 포트 설정

-R	
로컬 호스트와 지정된 포트로 전송될 원격 포트 설정

-i
:인증키를 가졌을때 이를 이용해서 접속할 때 명령어
--------------------------------------------------------------------
e.g)다음과 같이 사용한다.(bandit13풀이임 ㅇㅇ)
bandit13@melinda:~$ ssh -i ./sshkey.private bandit14@localhost
--------------------------------------------------------------------
-----------------------------------------------------------------------

*nc명령어: 넷캣(nc)는 TCP나 UDP프로토콜을 사용하는 네크워크 연결에서 데이터를
   	  읽고 쓰는 간단한 유틸리티 프로그램이다.

	   nc [옵션] [포트] 의 형식을 띈다.

	    cat와 비슷한 사용법을 가지지만 cat가 파일에 쓰거나 읽듯이
	    nc는 네트워크 커네션에 읽거나 쓴다.
------------------------------------------------------------
옵션:

-n
:호스트 네임과 포트를 숫자로만 입력

-u
:udp연결

-p
:local port 지정

-s
:local ip address 지정

-l
: listen모드로 port 오픈

e.g)

1. -l 옵션을 이용해서 포트를 LISTEN 상태로 열어둔다.

root@localhost ~]# nc -l 30000    //30000이 포트번호

2.다른 터미널에서 nc로 localhost에 30000포트로 접속한다. 접속이 됬다면 데이터를 입력해보자.
(다른 터미널임 ㅇㅇ)
root@localhost ~]# nc localhost 30000 
hi?

3. 다음과 같이 열어둔 포트를 열어 둔 터미널에서 출력된 데이터를 볼 수 있다.

root@localhost ~]# nc -l 30000
hi?
-----------------------------------------------------------


[OpenSSL]

-SSL(Secure Socket Layer)과 TLS(Transport Layer Security)는 보안 통신을 위해 사용하는 프로토콜이다.
 이 프로토콜을 구현한 라이브러리 중 하나가 open SLL이며 오픈소스로 구현되어 있다.
 OpenSLL 라이브러리는 통신 전문을 암호화할 수있으며, 문서를 암호화 할 수도 있다.

*s_client 명령어: OpenSLL과 관련된 테스트를 한 경우 필요한 경우 운영중인 웹 서버의 SLL인증서 정보
 	          등을 살펴 볼 수 있다. SSL/TLS를 사용하는 원격 호스트에 접속하기 위한 SSL/TLS client를 구현하는
 	          명령어이다.(더 구글링 ㄱㄱ)

[nmap]

-nmap은 network mapper의 줄임말로써 네트워크 탐색과 보안검사를 하는 오픈소스 툴이다.

-nmap은 네트워크상의 어떤 호스트가 작동중인지, 그 호스트가 어떤 
 서비스를 하는지, 운영체제가 무엇인지, 어떤 패킷필터나 방화벽을 쓰는지 
 등을 알아내기 위해 raw ip 패킷을 사용한다.

-nmap은 옵션에 따라서 스캔된 호스트의 추가 정보를 출력하는데, 그 정보 중 핵심은
 interesting ports table이다. 이 테이블은 스캔된 포트번호, 프로토콜, 상태(state)를 출력한다.
 state의 종류는 다음과 같다.(스캔 결과 상태가 여러게 조합되어 나타날 수 있다.)

---------------------------------------------------------
open
: 스캔된 포트가 listen 상태임을 나타냄

filtered
: 방화벽이나 필터에 막혀 해당 포트의 open, close 여부를 알 수 없을 때

closed
: 포트스캔을 한 시점에는 listen 상태가 아님을 나타냄

unfiltered
: nmap의 스캔에 응답은 하지만 해당 포트의 open, close 여부는 알 수 없을 때
----------------------------------------------------------





